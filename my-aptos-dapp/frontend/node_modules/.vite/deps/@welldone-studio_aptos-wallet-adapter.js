import {
  AptosClient,
  HexString,
  bcs_exports
} from "./chunk-52MOVFUN.js";
import "./chunk-PYKWRMZ7.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@welldone-studio/aptos-wallet-adapter/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert;

// node_modules/@welldone-studio/aptos-wallet-adapter/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (h, l) => l;
var rotr32L = (h, l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@welldone-studio/aptos-wallet-adapter/node_modules/@noble/hashes/esm/cryptoBrowser.js
var crypto = {
  node: void 0,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};

// node_modules/@welldone-studio/aptos-wallet-adapter/node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/@welldone-studio/aptos-wallet-adapter/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? u64_default.rotlBH(h, l, s) : u64_default.rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? u64_default.rotlBL(h, l, s) : u64_default.rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    assert_default.exists(this, false);
    assert_default.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    assert_default.number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    assert_default.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@welldone-studio/aptos-wallet-adapter/dist/index.mjs
var CancelError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CancelError";
  }
  get isCancelled() {
    return true;
  }
};
var CancelablePromise = class {
  constructor(executor) {
    this._isResolved = false;
    this._isRejected = false;
    this._isCancelled = false;
    this._cancelHandlers = [];
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
      const onResolve = (value) => {
        var _a;
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isResolved = true;
        (_a = this._resolve) == null ? void 0 : _a.call(this, value);
      };
      const onReject = (reason) => {
        var _a;
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isRejected = true;
        (_a = this._reject) == null ? void 0 : _a.call(this, reason);
      };
      const onCancel = (cancelHandler) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._cancelHandlers.push(cancelHandler);
      };
      Object.defineProperty(onCancel, "isResolved", {
        get: () => this._isResolved
      });
      Object.defineProperty(onCancel, "isRejected", {
        get: () => this._isRejected
      });
      Object.defineProperty(onCancel, "isCancelled", {
        get: () => this._isCancelled
      });
      return executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel() {
    var _a;
    if (this._isResolved || this._isRejected || this._isCancelled) {
      return;
    }
    this._isCancelled = true;
    if (this._cancelHandlers.length) {
      try {
        for (const cancelHandler of this._cancelHandlers) {
          cancelHandler();
        }
      } catch (error) {
        console.warn("Cancellation threw an error", error);
        return;
      }
    }
    this._cancelHandlers.length = 0;
    (_a = this._reject) == null ? void 0 : _a.call(this, new CancelError("Request aborted"));
  }
  get isCancelled() {
    return this._isCancelled;
  }
};
var WelldonePluginProvider = class {
  constructor() {
    this._account = null;
    this._networkId = null;
  }
  async connect() {
    try {
      const account = await window.dapp.request("aptos", {
        method: "dapp:accounts"
      });
      const accountInfo = {
        address: account["aptos"].address,
        publicKey: account["aptos"].pubKey
      };
      this._account = accountInfo;
      return accountInfo;
    } catch (error) {
      throw new Error("Connect Error: Unlock your WELLDONE Wallet OR Create Account");
    }
  }
  async account() {
    if (this._account) {
      return this._account;
    }
    throw new Error("Account Error: No Account");
  }
  async disconnect() {
    this._account = null;
  }
  async signAndSubmitTransaction(transaction, options) {
    if (!this._account) {
      throw new Error("Account Error: No Account");
    }
    if (!this._networkId) {
      throw new Error("Network Error: Not connected to the network");
    }
    try {
      const client = new AptosClient(this.aptosNodeUrl(this._networkId));
      const rawTx = await client.generateTransaction(
        this._account.address,
        transaction,
        options
      );
      const hash2 = sha3_256.create();
      hash2.update("APTOS::RawTransaction");
      const rawTxnWithSalt = HexString.fromUint8Array(new Uint8Array([...hash2.digest(), ...bcs_exports.bcsToBytes(rawTx)])).hex();
      const txHash = await window.dapp.request("aptos", {
        method: "dapp:signAndSendTransaction",
        params: [rawTxnWithSalt]
      });
      return { hash: txHash[0] };
    } catch (error) {
      throw error;
    }
  }
  async signMessage(message) {
    if (!this._account) {
      throw new Error("Account Error: No Account");
    }
    if (!this._networkId) {
      throw new Error("Network Error: Not connected to the network");
    }
    let fullMessage = "APTOS";
    if (message.address) {
      fullMessage += "\naddress: " + this._account.address;
    }
    if (message.application) {
      fullMessage += "\napplication: " + window.location.href;
    }
    if (message.chainId) {
      fullMessage += "\nchainId: " + this._networkId;
    }
    fullMessage += "\nmessage: " + message.message + "\nnonce: " + message.nonce;
    try {
      const response = await window.dapp.request("aptos", {
        method: "dapp:signMessage",
        params: [fullMessage]
      });
      const signMessageResponse = {
        address: this._account.address,
        application: window.location.href,
        chainId: this._networkId,
        fullMessage,
        message: message.message,
        nonce: message.nonce,
        prefix: "APTOS",
        signature: response[0].signature
      };
      return signMessageResponse;
    } catch (error) {
      throw error;
    }
  }
  async network() {
    const response = await this.request({
      method: "GET",
      url: "/"
    });
    this._networkId = response.chain_id;
    switch (this._networkId) {
      case 1:
        return "mainnet";
      case 2:
        return "testnet";
      default:
        return "devnet";
    }
  }
  async onAccountChange(listener) {
    window.dapp.on("dapp:accountsChanged", listener);
  }
  async onNetworkChange(listener) {
    window.dapp.on("dapp:chainChanged", async (newNetwork) => {
      const networkName = newNetwork.split(":")[1];
      const network = {
        networkName: {
          name: networkName
        }
      };
      await this.network();
      listener(network);
    });
  }
  aptosNodeUrl(chainId) {
    switch (chainId) {
      case 1:
        return "https://fullnode.mainnet.aptoslabs.com/v1";
      case 2:
        return "https://fullnode.testnet.aptoslabs.com/v1";
      default:
        return "https://fullnode.devnet.aptoslabs.com/v1";
    }
  }
  request(options) {
    return new CancelablePromise(async (resolve, reject, onCancel) => {
      try {
        if (!onCancel.isCancelled) {
          const response = await window.dapp.request("aptos", {
            method: options.method,
            params: [options]
          });
          resolve(response);
        }
      } catch (error) {
        reject(error);
      }
    });
  }
};
var WelldoneWalletName = "WELLDONE";
var WelldoneWallet = class {
  constructor() {
    this.name = WelldoneWalletName;
    this.url = "https://chrome.google.com/webstore/detail/welldone-wallet-for-multi/bmkakpenjmcpfhhjadflneinmhboecjf";
    this.icon = "data:image/png;base64,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";
    this.providerName = "welldone_aptos";
    this.provider = typeof window !== "undefined" && window.dapp ? window.welldone_aptos : void 0;
    if (typeof window != "undefined" && window.dapp) {
      window.welldone_aptos = new WelldonePluginProvider();
    }
  }
  async connect() {
    var _a;
    try {
      const accountInfo = await ((_a = this.provider) == null ? void 0 : _a.connect());
      if (!accountInfo)
        throw `${WelldoneWalletName} Address Info Error`;
      return accountInfo;
    } catch (error) {
      throw error;
    }
  }
  async account() {
    var _a;
    const response = await ((_a = this.provider) == null ? void 0 : _a.account());
    if (!response)
      throw `${WelldoneWalletName} Account Error`;
    return response;
  }
  async disconnect() {
    var _a;
    try {
      await ((_a = this.provider) == null ? void 0 : _a.disconnect());
    } catch (error) {
      throw error;
    }
  }
  async signAndSubmitTransaction(transaction, options) {
    var _a;
    try {
      const response = await ((_a = this.provider) == null ? void 0 : _a.signAndSubmitTransaction(
        transaction,
        options
      ));
      return response;
    } catch (error) {
      const errMsg = error.message;
      throw errMsg;
    }
  }
  async signMessage(message) {
    var _a;
    try {
      if (typeof message !== "object" || !message.nonce) {
        `${WelldoneWalletName} Invalid signMessage Payload`;
      }
      const response = await ((_a = this.provider) == null ? void 0 : _a.signMessage(message));
      if (response) {
        return response;
      } else {
        throw `${WelldoneWalletName} Sign Message failed`;
      }
    } catch (error) {
      const errMsg = error.message;
      throw errMsg;
    }
  }
  async network() {
    var _a;
    try {
      const response = await ((_a = this.provider) == null ? void 0 : _a.network());
      if (!response)
        throw `${WelldoneWalletName} Network Error`;
      return {
        name: response
      };
    } catch (error) {
      throw error;
    }
  }
  async onNetworkChange(callback) {
    var _a;
    try {
      const handleNetworkChange = async (newNetwork) => {
        callback({
          name: newNetwork.networkName.name,
          chainId: newNetwork.networkName.chainId,
          api: newNetwork.networkName.url
        });
      };
      await ((_a = this.provider) == null ? void 0 : _a.onNetworkChange(handleNetworkChange));
    } catch (error) {
      const errMsg = error.message;
      throw errMsg;
    }
  }
  async onAccountChange(callback) {
    var _a;
    try {
      const handleAccountChange = async (newAccount) => {
        if (newAccount == null ? void 0 : newAccount.publicKey) {
          callback({
            publicKey: newAccount.publicKey,
            address: newAccount.address
          });
        } else {
          const response = await this.connect();
          callback({
            address: response == null ? void 0 : response.address,
            publicKey: response == null ? void 0 : response.publicKey
          });
        }
      };
      await ((_a = this.provider) == null ? void 0 : _a.onAccountChange(handleAccountChange));
    } catch (error) {
      const errMsg = error.message;
      throw errMsg;
    }
  }
};
export {
  WelldoneWallet,
  WelldoneWalletName
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@welldone-studio_aptos-wallet-adapter.js.map
