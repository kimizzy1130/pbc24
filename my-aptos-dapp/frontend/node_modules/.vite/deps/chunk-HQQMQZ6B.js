import {
  require_buffer
} from "./chunk-R7WADFW2.js";
import {
  HexString,
  aptos_types_exports,
  bcs_exports
} from "./chunk-GBT3GB5Y.js";
import {
  require_jsx_runtime
} from "./chunk-ZYX7IIE4.js";
import {
  require_react
} from "./chunk-HS5T2ZWL.js";
import {
  secp256k1
} from "./chunk-QPQMJR4K.js";
import {
  require_nacl_fast
} from "./chunk-3WUHF2EA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number2(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number2;
    function bool2(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool2;
    function bytes2(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes2;
    function hash2(hash3) {
      if (typeof hash3 !== "function" || typeof hash3.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number2(hash3.outputLen);
      number2(hash3.blockLen);
    }
    exports.hash = hash2;
    function exists2(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists2;
    function output2(out, instance) {
      bytes2(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output2;
    var assert2 = {
      number: number2,
      bool: bool2,
      bytes: bytes2,
      hash: hash2,
      exists: exists2,
      output: output2
    };
    exports.default = assert2;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/cryptoBrowser.js
var require_cryptoBrowser = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/cryptoBrowser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = {
      node: void 0,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_cryptoBrowser();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u322;
    var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView2;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex2(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes2[uint8a[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex2;
    function hexToBytes2(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes2;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes2(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes2;
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes2(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes2;
    function concatBytes(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes;
    var Hash2 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash2;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor2(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes2(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor2;
    function wrapConstructorWithOpts2(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts2;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC2 = class extends utils_js_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash2);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    var hmac2 = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
    exports.hmac = hmac2;
    exports.hmac.create = (hash2, key) => new HMAC2(hash2, key);
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Async = exports.pbkdf2 = void 0;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash2, _password, _salt, _opts) {
      _assert_js_1.default.hash(hash2);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      _assert_js_1.default.number(c);
      _assert_js_1.default.number(dkLen);
      _assert_js_1.default.number(asyncTick);
      if (c < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash2, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u.fill(0);
      return DK;
    }
    function pbkdf2(hash2, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view2 = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view2.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2 = pbkdf2;
    async function pbkdf2Async(hash2, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view2 = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view2.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, (i) => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i2 = 0; i2 < Ti.length; i2++)
            Ti[i2] ^= u[i2];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2Async = pbkdf2Async;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint642(view2, byteOffset, value, isLE2) {
      if (typeof view2.setBigUint64 === "function")
        return view2.setBigUint64(byteOffset, value, isLE2);
      const _32n2 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n2 & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE2 ? 4 : 0;
      const l = isLE2 ? 0 : 4;
      view2.setUint32(byteOffset + h, wh, isLE2);
      view2.setUint32(byteOffset + l, wl, isLE2);
    }
    var SHA22 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view: view2, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view2, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view: view2, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view2, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint642(view2, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view2, 0);
        const oview = (0, utils_js_1.createView)(out);
        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE2));
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA22;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view2, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view2.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK642 = BigInt(2 ** 32 - 1);
    var _32n2 = BigInt(32);
    function fromBig2(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
      return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
    }
    exports.fromBig = fromBig2;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig2(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split2;
    var toBig2 = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
    exports.toBig = toBig2;
    var shrSH2 = (h, l, s) => h >>> s;
    var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H2 = (h, l) => l;
    var rotr32L2 = (h, l) => h;
    var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add2(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add2;
    var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u642 = {
      fromBig: fromBig2,
      split: split2,
      toBig: exports.toBig,
      shrSH: shrSH2,
      shrSL: shrSL2,
      rotrSH: rotrSH2,
      rotrSL: rotrSL2,
      rotrBH: rotrBH2,
      rotrBL: rotrBL2,
      rotr32H: rotr32H2,
      rotr32L: rotr32L2,
      rotlSH: rotlSH2,
      rotlSL: rotlSL2,
      rotlBH: rotlBH2,
      rotlBL: rotlBL2,
      add: add2,
      add3L: add3L2,
      add3H: add3H2,
      add4L: add4L2,
      add4H: add4H2,
      add5H: add5H2,
      add5L: add5L2
    };
    exports.default = u642;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512 = exports.SHA512 = void 0;
    var _sha2_js_1 = require_sha2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh2, SHA512_Kl2] = _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n)));
    var SHA512_W_H2 = new Uint32Array(80);
    var SHA512_W_L2 = new Uint32Array(80);
    var SHA5122 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view2, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H2[i] = view2.getUint32(offset);
          SHA512_W_L2[i] = view2.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H2[i - 15] | 0;
          const W15l = SHA512_W_L2[i - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H2[i - 2] | 0;
          const W2l = SHA512_W_L2[i - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L2[i - 7], SHA512_W_L2[i - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H2[i - 7], SHA512_W_H2[i - 16]);
          SHA512_W_H2[i] = SUMh | 0;
          SHA512_W_L2[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i], SHA512_W_L2[i]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i], SHA512_W_H2[i]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H2.fill(0);
        SHA512_W_L2.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA5122;
    var SHA512_2562 = class extends SHA5122 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA3842 = class extends SHA5122 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA5122());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2562());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA3842());
  }
});

// node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
    function assertNumber(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
    }
    exports.assertNumber = assertNumber;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function chain(...args) {
      const id = (a) => a;
      const wrap = (a, b) => (c) => a(b(c));
      const encode = args.map((x) => x.encode).reduceRight(wrap, id);
      const decode = args.map((x) => x.decode).reduce(wrap, id);
      return { encode, decode };
    }
    function alphabet(alphabet2) {
      return {
        encode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return digits.map((i) => {
            assertNumber(i);
            if (i < 0 || i >= alphabet2.length)
              throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
            return alphabet2[i];
          });
        },
        decode: (input) => {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("alphabet.decode input should be array of strings");
          return input.map((letter) => {
            if (typeof letter !== "string")
              throw new Error(`alphabet.decode: not string element=${letter}`);
            const index = alphabet2.indexOf(letter);
            if (index === -1)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
            return index;
          });
        }
      };
    }
    function join(separator = "") {
      if (typeof separator !== "string")
        throw new Error("join separator should be string");
      return {
        encode: (from) => {
          if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
            throw new Error("join.encode input should be array of strings");
          for (let i of from)
            if (typeof i !== "string")
              throw new Error(`join.encode: non-string input=${i}`);
          return from.join(separator);
        },
        decode: (to) => {
          if (typeof to !== "string")
            throw new Error("join.decode input should be string");
          return to.split(separator);
        }
      };
    }
    function padding(bits, chr = "=") {
      assertNumber(bits);
      if (typeof chr !== "string")
        throw new Error("padding chr should be string");
      return {
        encode(data) {
          if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i of data)
            if (typeof i !== "string")
              throw new Error(`padding.encode: non-string input=${i}`);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i of input)
            if (typeof i !== "string")
              throw new Error(`padding.decode: non-string input=${i}`);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            if (!((end - 1) * bits % 8))
              throw new Error("Invalid padding: string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize(fn) {
      if (typeof fn !== "function")
        throw new Error("normalize fn should be function");
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix(data, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
      if (!Array.isArray(data))
        throw new Error("convertRadix: data should be array");
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data);
      digits.forEach((d) => {
        assertNumber(d);
        if (d < 0 || d >= from)
          throw new Error(`Wrong integer: ${d}`);
      });
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
          const digit = digits[i];
          const digitBase = from * carry + digit;
          if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
            throw new Error("convertRadix: carry overflow");
          }
          carry = digitBase % to;
          const rounded = Math.floor(digitBase / to);
          digits[i] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
      return res.reverse();
    }
    var gcd = (a, b) => !b ? a : gcd(b, a % b);
    var radix2carry = (from, to) => from + (to - gcd(from, to));
    function convertRadix2(data, from, to, padding2) {
      if (!Array.isArray(data))
        throw new Error("convertRadix2: data should be array");
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const mask = 2 ** to - 1;
      const res = [];
      for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        carry &= 2 ** pos - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding2 && pos >= from)
        throw new Error("Excess padding");
      if (!padding2 && carry)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix(num) {
      assertNumber(num);
      return {
        encode: (bytes2) => {
          if (!isBytes(bytes2))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes2), 2 ** 8, num);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix.decode input should be array of numbers");
          return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        }
      };
    }
    function radix2(bits, revPadding = false) {
      assertNumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes2) => {
          if (!isBytes(bytes2))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix2.decode input should be array of numbers");
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper(fn) {
      if (typeof fn !== "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e) {
        }
      };
    }
    function checksum(len, fn) {
      assertNumber(len);
      if (typeof fn !== "function")
        throw new Error("checksum fn should be function");
      return {
        encode(data) {
          if (!isBytes(data))
            throw new Error("checksum.encode: input should be Uint8Array");
          const checksum2 = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(checksum2, data.length);
          return res;
        },
        decode(data) {
          if (!isBytes(data))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const newChecksum = fn(payload).slice(0, len);
          const oldChecksum = data.slice(-len);
          for (let i = 0; i < len; i++)
            if (newChecksum[i] !== oldChecksum[i])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = {
      alphabet,
      chain,
      checksum,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join,
      padding
    };
    exports.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
    exports.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
    exports.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
    exports.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    exports.base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
    exports.base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
    exports.base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
    var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
    exports.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i = 0; i < data.length; i += 8) {
          const block = data.subarray(i, i + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
          const slice = str.slice(i, i + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
    exports.createBase58check = createBase58check;
    exports.base58check = exports.createBase58check;
    var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
    var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod(pre) {
      const b = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if ((b >> i & 1) === 1)
          chk ^= POLYMOD_GENERATORS[i];
      }
      return chk;
    }
    function bechChecksum(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
      }
      chk = bech32Polymod(chk);
      for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
      for (let v of words)
        chk = bech32Polymod(chk) ^ v;
      for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
    }
    function genBech32(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix2(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper(fromWords);
      function encode(prefix, words, limit = 90) {
        if (typeof prefix !== "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
      }
      function decode(str, limit = 90) {
        if (typeof str !== "string")
          throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit !== false && str.length > limit)
          throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words2 = str.slice(sepIndex + 1);
        if (_words2.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words2.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper(decode);
      function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
    }
    exports.bech32 = genBech32("bech32");
    exports.bech32m = genBech32("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    exports.hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
      if (typeof s !== "string" || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
      return s.toLowerCase();
    }));
    var CODERS = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    var bytesToString = (type, bytes2) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!isBytes(bytes2))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes2);
    };
    exports.bytesToString = bytesToString;
    exports.str = exports.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports.stringToBytes = stringToBytes;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
    var _assert_1 = require_assert();
    var pbkdf2_1 = require_pbkdf2();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) => wordlist[0] === "";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function assertEntropy(entropy) {
      _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      _assert_1.default.number(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
    }
    exports.generateMnemonic = generateMnemonic;
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist) {
      if (!Array.isArray(wordlist) || wordlist.length !== 2 ** 11 || typeof wordlist[0] !== "string")
        throw new Error("Worlist: expected array of 2048 strings");
      wordlist.forEach((i) => {
        if (typeof i !== "string")
          throw new Error(`Wordlist: non-string element: ${i}`);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      assertEntropy(entropy);
      return entropy;
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      assertEntropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "" : " ");
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    exports.validateMnemonic = validateMnemonic;
    var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
    function mnemonicToSeed2(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeed = mnemonicToSeed2;
    function mnemonicToSeedSync2(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeedSync = mnemonicToSeedSync2;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    var kindOf = function(cache2) {
      return function(thing) {
        var str = toString.call(thing);
        return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber2(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i = thing.length;
      if (isUndefined(i))
        return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray = function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber2,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/AxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function AxiosError(message, code, config, request2, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request2 && (this.request = request2);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = function(error, code, config, request2, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError.call(axiosError, error.message, code, config, request2, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module.exports = AxiosError;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/toFormData.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function toFormData(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build(obj);
      return formData;
    }
    module.exports = toFormData;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var AxiosError = require_AxiosError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/cancel/CanceledError.js"(exports, module) {
    "use strict";
    var AxiosError = require_AxiosError();
    var utils = require_utils2();
    function CanceledError(message) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    module.exports = CanceledError;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/parseProtocol.js"(exports, module) {
    "use strict";
    module.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request2 = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request2.timeout = config.timeout;
        function onloadend() {
          if (!request2) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders(request2.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
          var response = {
            data: responseData,
            status: request2.status,
            statusText: request2.statusText,
            headers: responseHeaders,
            config,
            request: request2
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request2 = null;
        }
        if ("onloadend" in request2) {
          request2.onloadend = onloadend;
        } else {
          request2.onreadystatechange = function handleLoad() {
            if (!request2 || request2.readyState !== 4) {
              return;
            }
            if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request2.onabort = function handleAbort() {
          if (!request2) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
          request2 = null;
        };
        request2.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2, request2));
          request2 = null;
        };
        request2.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request2
          ));
          request2 = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request2) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request2.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request2.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request2.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request2.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request2.upload) {
          request2.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request2) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request2.abort();
            request2 = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request2.send(requestData);
      });
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/null.js
var require_null = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/null.js"(exports, module) {
    module.exports = null;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var AxiosError = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_null()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.27.2"
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION2 = require_data().version;
    var AxiosError = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var buildFullPath = require_buildFullPath();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request2(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module.exports = Axios;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.CanceledError = require_CanceledError();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.toFormData = require_toFormData();
    axios2.AxiosError = require_AxiosError();
    axios2.Cancel = axios2.CanceledError;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module.exports = axios2;
    module.exports.default = axios2;
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/esm/cryptoBrowser.js
var crypto = {
  node: void 0,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert;

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (h, l) => l;
var rotr32L = (h, l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? u64_default.rotlBH(h, l, s) : u64_default.rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? u64_default.rotlBL(h, l, s) : u64_default.rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    assert_default.exists(this, false);
    assert_default.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    assert_default.number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    assert_default.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/ts-sdk/dist/esm/index.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view2, byteOffset, value, isLE2) {
  if (typeof view2.setBigUint64 === "function")
    return view2.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view2.setUint32(byteOffset + h, wh, isLE2);
  view2.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view: view2, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view2, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, view: view2, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view2, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view2, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view2, 0);
    const oview = createView(out);
    this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE2));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n)));
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view2, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view2.getUint32(offset);
      SHA512_W_L[i] = view2.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/ts-sdk/dist/esm/index.mjs
var bip39 = __toESM(require_bip39(), 1);

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/aptos-client/dist/browser/index.browser.mjs
var import_axios = __toESM(require_axios2(), 1);
async function aptosClient(options) {
  var _a;
  const { params, method, url, headers, body, overrides } = options;
  const requestConfig = {
    headers,
    method,
    url,
    params,
    data: body,
    withCredentials: (_a = overrides == null ? void 0 : overrides.WITH_CREDENTIALS) != null ? _a : true
  };
  try {
    const response = await (0, import_axios.default)(requestConfig);
    return {
      status: response.status,
      statusText: response.statusText,
      data: response.data,
      headers: response.headers,
      config: response.config
    };
  } catch (error) {
    const axiosError = error;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
}

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/ts-sdk/dist/esm/index.mjs
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var AptosApiError = class extends Error {
  constructor(request2, response, message) {
    super(message);
    this.name = "AptosApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.data = response.data;
    this.request = request2;
  }
};
var VERSION = "2.0.0";
var MimeType = ((MimeType2) => {
  MimeType2["JSON"] = "application/json";
  MimeType2["BCS"] = "application/x-bcs";
  MimeType2["BCS_SIGNED_TRANSACTION"] = "application/x.aptos.signed_transaction+bcs";
  return MimeType2;
})(MimeType || {});
var TypeTagVariants = ((TypeTagVariants2) => {
  TypeTagVariants2[TypeTagVariants2["Bool"] = 0] = "Bool";
  TypeTagVariants2[TypeTagVariants2["U8"] = 1] = "U8";
  TypeTagVariants2[TypeTagVariants2["U64"] = 2] = "U64";
  TypeTagVariants2[TypeTagVariants2["U128"] = 3] = "U128";
  TypeTagVariants2[TypeTagVariants2["Address"] = 4] = "Address";
  TypeTagVariants2[TypeTagVariants2["Signer"] = 5] = "Signer";
  TypeTagVariants2[TypeTagVariants2["Vector"] = 6] = "Vector";
  TypeTagVariants2[TypeTagVariants2["Struct"] = 7] = "Struct";
  TypeTagVariants2[TypeTagVariants2["U16"] = 8] = "U16";
  TypeTagVariants2[TypeTagVariants2["U32"] = 9] = "U32";
  TypeTagVariants2[TypeTagVariants2["U256"] = 10] = "U256";
  TypeTagVariants2[TypeTagVariants2["Reference"] = 254] = "Reference";
  TypeTagVariants2[TypeTagVariants2["Generic"] = 255] = "Generic";
  return TypeTagVariants2;
})(TypeTagVariants || {});
var ScriptTransactionArgumentVariants = ((ScriptTransactionArgumentVariants2) => {
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U8"] = 0] = "U8";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U64"] = 1] = "U64";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U128"] = 2] = "U128";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["Address"] = 3] = "Address";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U8Vector"] = 4] = "U8Vector";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["Bool"] = 5] = "Bool";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U16"] = 6] = "U16";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U32"] = 7] = "U32";
  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2["U256"] = 8] = "U256";
  return ScriptTransactionArgumentVariants2;
})(ScriptTransactionArgumentVariants || {});
var TransactionPayloadVariants = ((TransactionPayloadVariants2) => {
  TransactionPayloadVariants2[TransactionPayloadVariants2["Script"] = 0] = "Script";
  TransactionPayloadVariants2[TransactionPayloadVariants2["EntryFunction"] = 2] = "EntryFunction";
  TransactionPayloadVariants2[TransactionPayloadVariants2["Multisig"] = 3] = "Multisig";
  return TransactionPayloadVariants2;
})(TransactionPayloadVariants || {});
var TransactionVariants = ((TransactionVariants2) => {
  TransactionVariants2[TransactionVariants2["MultiAgentTransaction"] = 0] = "MultiAgentTransaction";
  TransactionVariants2[TransactionVariants2["FeePayerTransaction"] = 1] = "FeePayerTransaction";
  return TransactionVariants2;
})(TransactionVariants || {});
var TransactionAuthenticatorVariant = ((TransactionAuthenticatorVariant2) => {
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["Ed25519"] = 0] = "Ed25519";
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["MultiEd25519"] = 1] = "MultiEd25519";
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["MultiAgent"] = 2] = "MultiAgent";
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["FeePayer"] = 3] = "FeePayer";
  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2["SingleSender"] = 4] = "SingleSender";
  return TransactionAuthenticatorVariant2;
})(TransactionAuthenticatorVariant || {});
var AccountAuthenticatorVariant = ((AccountAuthenticatorVariant2) => {
  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2["Ed25519"] = 0] = "Ed25519";
  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2["MultiEd25519"] = 1] = "MultiEd25519";
  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2["SingleKey"] = 2] = "SingleKey";
  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2["MultiKey"] = 3] = "MultiKey";
  return AccountAuthenticatorVariant2;
})(AccountAuthenticatorVariant || {});
var AnyPublicKeyVariant = ((AnyPublicKeyVariant2) => {
  AnyPublicKeyVariant2[AnyPublicKeyVariant2["Ed25519"] = 0] = "Ed25519";
  AnyPublicKeyVariant2[AnyPublicKeyVariant2["Secp256k1"] = 1] = "Secp256k1";
  return AnyPublicKeyVariant2;
})(AnyPublicKeyVariant || {});
var AnySignatureVariant = ((AnySignatureVariant2) => {
  AnySignatureVariant2[AnySignatureVariant2["Ed25519"] = 0] = "Ed25519";
  AnySignatureVariant2[AnySignatureVariant2["Secp256k1"] = 1] = "Secp256k1";
  return AnySignatureVariant2;
})(AnySignatureVariant || {});
var TransactionResponseType = ((TransactionResponseType2) => {
  TransactionResponseType2["Pending"] = "pending_transaction";
  TransactionResponseType2["User"] = "user_transaction";
  TransactionResponseType2["Genesis"] = "genesis_transaction";
  TransactionResponseType2["BlockMetadata"] = "block_metadata_transaction";
  TransactionResponseType2["StateCheckpoint"] = "state_checkpoint_transaction";
  return TransactionResponseType2;
})(TransactionResponseType || {});
var MoveFunctionVisibility = ((MoveFunctionVisibility2) => {
  MoveFunctionVisibility2["PRIVATE"] = "private";
  MoveFunctionVisibility2["PUBLIC"] = "public";
  MoveFunctionVisibility2["FRIEND"] = "friend";
  return MoveFunctionVisibility2;
})(MoveFunctionVisibility || {});
var MoveAbility = ((MoveAbility2) => {
  MoveAbility2["STORE"] = "store";
  MoveAbility2["DROP"] = "drop";
  MoveAbility2["KEY"] = "key";
  MoveAbility2["COPY"] = "copy";
  return MoveAbility2;
})(MoveAbility || {});
var RoleType = ((RoleType2) => {
  RoleType2["VALIDATOR"] = "validator";
  RoleType2["FULL_NODE"] = "full_node";
  return RoleType2;
})(RoleType || {});
var SigningScheme = ((SigningScheme2) => {
  SigningScheme2[SigningScheme2["Ed25519"] = 0] = "Ed25519";
  SigningScheme2[SigningScheme2["MultiEd25519"] = 1] = "MultiEd25519";
  SigningScheme2[SigningScheme2["SingleKey"] = 2] = "SingleKey";
  SigningScheme2[SigningScheme2["MultiKey"] = 3] = "MultiKey";
  return SigningScheme2;
})(SigningScheme || {});
var SigningSchemeInput = ((SigningSchemeInput2) => {
  SigningSchemeInput2[SigningSchemeInput2["Ed25519"] = 0] = "Ed25519";
  SigningSchemeInput2[SigningSchemeInput2["Secp256k1Ecdsa"] = 2] = "Secp256k1Ecdsa";
  return SigningSchemeInput2;
})(SigningSchemeInput || {});
var DeriveScheme = ((DeriveScheme2) => {
  DeriveScheme2[DeriveScheme2["DeriveAuid"] = 251] = "DeriveAuid";
  DeriveScheme2[DeriveScheme2["DeriveObjectAddressFromObject"] = 252] = "DeriveObjectAddressFromObject";
  DeriveScheme2[DeriveScheme2["DeriveObjectAddressFromGuid"] = 253] = "DeriveObjectAddressFromGuid";
  DeriveScheme2[DeriveScheme2["DeriveObjectAddressFromSeed"] = 254] = "DeriveObjectAddressFromSeed";
  DeriveScheme2[DeriveScheme2["DeriveResourceAccountAddress"] = 255] = "DeriveResourceAccountAddress";
  return DeriveScheme2;
})(DeriveScheme || {});
var errors = {
  400: "Bad Request",
  401: "Unauthorized",
  403: "Forbidden",
  404: "Not Found",
  429: "Too Many Requests",
  500: "Internal Server Error",
  502: "Bad Gateway",
  503: "Service Unavailable"
};
async function request(options, client) {
  const { url, method, body, contentType, params, overrides } = options;
  const headers = {
    ...overrides == null ? void 0 : overrides.HEADERS,
    "x-aptos-client": `aptos-ts-sdk/${VERSION}`,
    "content-type": contentType != null ? contentType : "application/json"
    /* JSON */
  };
  if (overrides == null ? void 0 : overrides.TOKEN) {
    headers.Authorization = `Bearer ${overrides == null ? void 0 : overrides.TOKEN}`;
  }
  return client.provider({
    url,
    method,
    body,
    params,
    headers,
    overrides
  });
}
async function aptosRequest(options, aptosConfig) {
  var _a;
  const { url, path } = options;
  const fullUrl = `${url}/${path != null ? path : ""}`;
  const response = await request({ ...options, url: fullUrl }, aptosConfig.client);
  const result = {
    status: response.status,
    statusText: response.statusText,
    data: response.data,
    headers: response.headers,
    config: response.config,
    request: response.request,
    url: fullUrl
  };
  if (aptosConfig.isIndexerRequest(url)) {
    const indexerResponse = result.data;
    if (indexerResponse.errors) {
      throw new AptosApiError(
        options,
        result,
        (_a = indexerResponse.errors[0].message) != null ? _a : `Unhandled Error ${response.status} : ${response.statusText}`
      );
    }
    result.data = indexerResponse.data;
  }
  if (result.status >= 200 && result.status < 300) {
    return result;
  }
  const errorMessage = errors[result.status];
  throw new AptosApiError(
    options,
    result,
    errorMessage != null ? errorMessage : `Unhandled Error ${response.status} : ${response.statusText}`
  );
}
var NetworkToIndexerAPI = {
  mainnet: "https://indexer.mainnet.aptoslabs.com/v1/graphql",
  testnet: "https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql",
  devnet: "https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql",
  local: "http://127.0.0.1:8090/v1/graphql"
};
var NetworkToNodeAPI = {
  mainnet: "https://fullnode.mainnet.aptoslabs.com/v1",
  testnet: "https://fullnode.testnet.aptoslabs.com/v1",
  devnet: "https://fullnode.devnet.aptoslabs.com/v1",
  local: "http://127.0.0.1:8080/v1"
};
var NetworkToFaucetAPI = {
  mainnet: "https://faucet.mainnet.aptoslabs.com",
  testnet: "https://faucet.testnet.aptoslabs.com",
  devnet: "https://faucet.devnet.aptoslabs.com",
  local: "http://127.0.0.1:8081"
};
var Network = ((Network2) => {
  Network2["MAINNET"] = "mainnet";
  Network2["TESTNET"] = "testnet";
  Network2["DEVNET"] = "devnet";
  Network2["LOCAL"] = "local";
  Network2["CUSTOM"] = "custom";
  return Network2;
})(Network || {});
var NetworkToChainId = {
  mainnet: 1,
  testnet: 2
};
var DEFAULT_NETWORK = "devnet";
var DEFAULT_MAX_GAS_AMOUNT = 2e5;
var DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;
var DEFAULT_TXN_TIMEOUT_SEC = 20;
var APTOS_COIN = "0x1::aptos_coin::AptosCoin";
var RAW_TRANSACTION_SALT = "APTOS::RawTransaction";
var RAW_TRANSACTION_WITH_DATA_SALT = "APTOS::RawTransactionWithData";
async function get(options) {
  const { aptosConfig, overrides, params, contentType, acceptType, path, originMethod, type } = options;
  const url = aptosConfig.getRequestUrl(type);
  return aptosRequest(
    {
      url,
      method: "GET",
      originMethod,
      path,
      contentType: contentType == null ? void 0 : contentType.valueOf(),
      acceptType: acceptType == null ? void 0 : acceptType.valueOf(),
      params,
      overrides: {
        ...aptosConfig.clientConfig,
        ...overrides
      }
    },
    aptosConfig
  );
}
async function getAptosFullNode(options) {
  return get({
    ...options,
    type: 0
    /* FULLNODE */
  });
}
async function paginateWithCursor(options) {
  const out = [];
  let cursor;
  const requestParams = options.params;
  while (true) {
    requestParams.start = cursor;
    const response = await getAptosFullNode({
      aptosConfig: options.aptosConfig,
      originMethod: options.originMethod,
      path: options.path,
      params: requestParams,
      overrides: options.overrides
    });
    cursor = response.headers["x-aptos-cursor"];
    delete response.headers;
    out.push(...response.data);
    if (cursor === null || cursor === void 0) {
      break;
    }
  }
  return out;
}
async function post(options) {
  const { type, originMethod, path, body, acceptType, contentType, params, aptosConfig, overrides } = options;
  const url = aptosConfig.getRequestUrl(type);
  return aptosRequest(
    {
      url,
      method: "POST",
      originMethod,
      path,
      body,
      contentType: contentType == null ? void 0 : contentType.valueOf(),
      acceptType: acceptType == null ? void 0 : acceptType.valueOf(),
      params,
      overrides: {
        ...aptosConfig.clientConfig,
        ...overrides
      }
    },
    aptosConfig
  );
}
async function postAptosFullNode(options) {
  return post({
    ...options,
    type: 0
    /* FULLNODE */
  });
}
async function postAptosIndexer(options) {
  return post({
    ...options,
    type: 1
    /* INDEXER */
  });
}
async function postAptosFaucet(options) {
  return post({
    ...options,
    type: 2
    /* FAUCET */
  });
}
var MAX_U8_NUMBER = 2 ** 8 - 1;
var MAX_U16_NUMBER = 2 ** 16 - 1;
var MAX_U32_NUMBER = 2 ** 32 - 1;
var MAX_U64_BIG_INT = BigInt(2) ** BigInt(64) - BigInt(1);
var MAX_U128_BIG_INT = BigInt(2) ** BigInt(128) - BigInt(1);
var MAX_U256_BIG_INT = BigInt(2) ** BigInt(256) - BigInt(1);
var ParsingError = class extends Error {
  constructor(message, invalidReason) {
    super(message);
    this.invalidReason = invalidReason;
  }
};
var HexInvalidReason = ((HexInvalidReason2) => {
  HexInvalidReason2["TOO_SHORT"] = "too_short";
  HexInvalidReason2["INVALID_LENGTH"] = "invalid_length";
  HexInvalidReason2["INVALID_HEX_CHARS"] = "invalid_hex_chars";
  return HexInvalidReason2;
})(HexInvalidReason || {});
var Hex = class {
  constructor(data) {
    this.data = data;
  }
  toUint8Array() {
    return this.data;
  }
  toStringWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  static fromString(str) {
    let input = str;
    if (input.startsWith("0x")) {
      input = input.slice(2);
    }
    if (input.length === 0) {
      throw new ParsingError(
        "Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.",
        "too_short"
        /* TOO_SHORT */
      );
    }
    if (input.length % 2 !== 0) {
      throw new ParsingError(
        "Hex string must be an even number of hex characters.",
        "invalid_length"
        /* INVALID_LENGTH */
      );
    }
    try {
      return new Hex(hexToBytes(input));
    } catch (e) {
      const error = e;
      throw new ParsingError(
        `Hex string contains invalid hex characters: ${error.message}`,
        "invalid_hex_chars"
        /* INVALID_HEX_CHARS */
      );
    }
  }
  static fromHexInput(hexInput) {
    if (hexInput instanceof Uint8Array)
      return new Hex(hexInput);
    return Hex.fromString(hexInput);
  }
  static isValid(str) {
    try {
      Hex.fromString(str);
      return { valid: true };
    } catch (e) {
      const error = e;
      return {
        valid: false,
        invalidReason: error.invalidReason,
        invalidReasonMessage: error.message
      };
    }
  }
  equals(other) {
    if (this.data.length !== other.data.length)
      return false;
    return this.data.every((value, index) => value === other.data[index]);
  }
};
var Serializable = class {
  bcsToBytes() {
    const serializer = new Serializer();
    this.serialize(serializer);
    return serializer.toUint8Array();
  }
  bcsToHex() {
    const bcsBytes = this.bcsToBytes();
    return Hex.fromHexInput(bcsBytes);
  }
};
var Serializer = class {
  constructor(length = 64) {
    if (length <= 0) {
      throw new Error("Length needs to be greater than 0");
    }
    this.buffer = new ArrayBuffer(length);
    this.offset = 0;
  }
  ensureBufferWillHandleSize(bytes2) {
    while (this.buffer.byteLength < this.offset + bytes2) {
      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
      this.buffer = newBuffer;
    }
  }
  appendToBuffer(values) {
    this.ensureBufferWillHandleSize(values.length);
    new Uint8Array(this.buffer, this.offset).set(values);
    this.offset += values.length;
  }
  serializeWithFunction(fn, bytesLength, value) {
    this.ensureBufferWillHandleSize(bytesLength);
    const dv = new DataView(this.buffer, this.offset);
    fn.apply(dv, [0, value, true]);
    this.offset += bytesLength;
  }
  serializeStr(value) {
    const textEncoder = new TextEncoder();
    this.serializeBytes(textEncoder.encode(value));
  }
  serializeBytes(value) {
    this.serializeU32AsUleb128(value.length);
    this.appendToBuffer(value);
  }
  serializeFixedBytes(value) {
    this.appendToBuffer(value);
  }
  serializeBool(value) {
    ensureBoolean(value);
    const byteValue = value ? 1 : 0;
    this.appendToBuffer(new Uint8Array([byteValue]));
  }
  serializeU8(value) {
    this.appendToBuffer(new Uint8Array([value]));
  }
  serializeU16(value) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);
  }
  serializeU32(value) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);
  }
  serializeU64(value) {
    const low = BigInt(value) & BigInt(MAX_U32_NUMBER);
    const high = BigInt(value) >> BigInt(32);
    this.serializeU32(Number(low));
    this.serializeU32(Number(high));
  }
  serializeU128(value) {
    const low = BigInt(value) & MAX_U64_BIG_INT;
    const high = BigInt(value) >> BigInt(64);
    this.serializeU64(low);
    this.serializeU64(high);
  }
  serializeU256(value) {
    const low = BigInt(value) & MAX_U128_BIG_INT;
    const high = BigInt(value) >> BigInt(128);
    this.serializeU128(low);
    this.serializeU128(high);
  }
  serializeU32AsUleb128(val) {
    let value = val;
    const valueArray = [];
    while (value >>> 7 !== 0) {
      valueArray.push(value & 127 | 128);
      value >>>= 7;
    }
    valueArray.push(value);
    this.appendToBuffer(new Uint8Array(valueArray));
  }
  toUint8Array() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
  serialize(value) {
    value.serialize(this);
  }
  serializeVector(values) {
    this.serializeU32AsUleb128(values.length);
    values.forEach((item) => {
      item.serialize(this);
    });
  }
};
__decorateClass([
  checkNumberRange(0, MAX_U8_NUMBER)
], Serializer.prototype, "serializeU8", 1);
__decorateClass([
  checkNumberRange(0, MAX_U16_NUMBER)
], Serializer.prototype, "serializeU16", 1);
__decorateClass([
  checkNumberRange(0, MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U64_BIG_INT)
], Serializer.prototype, "serializeU64", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U128_BIG_INT)
], Serializer.prototype, "serializeU128", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U256_BIG_INT)
], Serializer.prototype, "serializeU256", 1);
__decorateClass([
  checkNumberRange(0, MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32AsUleb128", 1);
function ensureBoolean(value) {
  if (typeof value !== "boolean") {
    throw new Error(`${value} is not a boolean value`);
  }
}
var outOfRangeErrorMessage = (value, min, max) => `${value} is out of range: [${min}, ${max}]`;
function validateNumberInRange(value, minValue, maxValue) {
  const valueBigInt = BigInt(value);
  if (valueBigInt > BigInt(maxValue) || valueBigInt < BigInt(minValue)) {
    throw new Error(outOfRangeErrorMessage(value, minValue, maxValue));
  }
}
function checkNumberRange(minValue, maxValue) {
  return (target, propertyKey, descriptor) => {
    const childFunction = descriptor.value;
    descriptor.value = function deco(value) {
      validateNumberInRange(value, minValue, maxValue);
      return childFunction.apply(this, [value]);
    };
    return descriptor;
  };
}
var AddressInvalidReason = ((AddressInvalidReason2) => {
  AddressInvalidReason2["INCORRECT_NUMBER_OF_BYTES"] = "incorrect_number_of_bytes";
  AddressInvalidReason2["INVALID_HEX_CHARS"] = "invalid_hex_chars";
  AddressInvalidReason2["TOO_SHORT"] = "too_short";
  AddressInvalidReason2["TOO_LONG"] = "too_long";
  AddressInvalidReason2["LEADING_ZERO_X_REQUIRED"] = "leading_zero_x_required";
  AddressInvalidReason2["LONG_FORM_REQUIRED_UNLESS_SPECIAL"] = "long_form_required_unless_special";
  AddressInvalidReason2["INVALID_PADDING_ZEROES"] = "INVALID_PADDING_ZEROES";
  return AddressInvalidReason2;
})(AddressInvalidReason || {});
var _AccountAddress = class extends Serializable {
  constructor(args) {
    super();
    if (args.data.length !== _AccountAddress.LENGTH) {
      throw new ParsingError(
        "AccountAddress data should be exactly 32 bytes long",
        "incorrect_number_of_bytes"
        /* INCORRECT_NUMBER_OF_BYTES */
      );
    }
    this.data = args.data;
  }
  isSpecial() {
    return this.data.slice(0, this.data.length - 1).every((byte) => byte === 0) && this.data[this.data.length - 1] < 16;
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  toStringWithoutPrefix() {
    let hex = bytesToHex(this.data);
    if (this.isSpecial()) {
      hex = hex[hex.length - 1];
    }
    return hex;
  }
  toStringLong() {
    return `0x${this.toStringLongWithoutPrefix()}`;
  }
  toStringLongWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toUint8Array() {
    return this.data;
  }
  serialize(serializer) {
    serializer.serializeFixedBytes(this.data);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* Address */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeFixedBytes(_AccountAddress.LENGTH);
    return new _AccountAddress({ data: bytes2 });
  }
  static fromString(input) {
    if (!input.startsWith("0x")) {
      throw new ParsingError(
        "Hex string must start with a leading 0x.",
        "leading_zero_x_required"
        /* LEADING_ZERO_X_REQUIRED */
      );
    }
    const address = _AccountAddress.fromStringRelaxed(input);
    if (input.length !== _AccountAddress.LONG_STRING_LENGTH + 2) {
      if (!address.isSpecial()) {
        throw new ParsingError(
          `The given hex string ${address} is not a special address, it must be represented as 0x + 64 chars.`,
          "long_form_required_unless_special"
          /* LONG_FORM_REQUIRED_UNLESS_SPECIAL */
        );
      } else if (input.length !== 3) {
        throw new ParsingError(
          `The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`,
          "INVALID_PADDING_ZEROES"
          /* INVALID_PADDING_ZEROES */
        );
      }
    }
    return address;
  }
  static fromStringRelaxed(input) {
    let parsedInput = input;
    if (input.startsWith("0x")) {
      parsedInput = input.slice(2);
    }
    if (parsedInput.length === 0) {
      throw new ParsingError(
        "Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.",
        "too_short"
        /* TOO_SHORT */
      );
    }
    if (parsedInput.length > 64) {
      throw new ParsingError(
        "Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.",
        "too_long"
        /* TOO_LONG */
      );
    }
    let addressBytes;
    try {
      addressBytes = hexToBytes(parsedInput.padStart(64, "0"));
    } catch (e) {
      const error = e;
      throw new ParsingError(
        `Hex characters are invalid: ${error.message}`,
        "invalid_hex_chars"
        /* INVALID_HEX_CHARS */
      );
    }
    return new _AccountAddress({ data: addressBytes });
  }
  static fromHexInput(input) {
    if (input instanceof Uint8Array) {
      return new _AccountAddress({ data: input });
    }
    return _AccountAddress.fromString(input);
  }
  static fromHexInputRelaxed(hexInput) {
    if (hexInput instanceof Uint8Array) {
      return new _AccountAddress({ data: hexInput });
    }
    return _AccountAddress.fromStringRelaxed(hexInput);
  }
  static isValid(args) {
    try {
      if (args.relaxed) {
        _AccountAddress.fromStringRelaxed(args.input);
      } else {
        _AccountAddress.fromString(args.input);
      }
      return { valid: true };
    } catch (e) {
      const error = e;
      return {
        valid: false,
        invalidReason: error.invalidReason,
        invalidReasonMessage: error.message
      };
    }
  }
  equals(other) {
    if (this.data.length !== other.data.length)
      return false;
    return this.data.every((value, index) => value === other.data[index]);
  }
};
var AccountAddress = _AccountAddress;
AccountAddress.LENGTH = 32;
AccountAddress.LONG_STRING_LENGTH = 64;
AccountAddress.ZERO = _AccountAddress.fromString("0x0");
AccountAddress.ONE = _AccountAddress.fromString("0x1");
AccountAddress.TWO = _AccountAddress.fromString("0x2");
AccountAddress.THREE = _AccountAddress.fromString("0x3");
AccountAddress.FOUR = _AccountAddress.fromString("0x4");
var Deserializer = class {
  constructor(data) {
    this.buffer = new ArrayBuffer(data.length);
    new Uint8Array(this.buffer).set(data, 0);
    this.offset = 0;
  }
  read(length) {
    if (this.offset + length > this.buffer.byteLength) {
      throw new Error("Reached to the end of buffer");
    }
    const bytes2 = this.buffer.slice(this.offset, this.offset + length);
    this.offset += length;
    return bytes2;
  }
  deserializeStr() {
    const value = this.deserializeBytes();
    const textDecoder = new TextDecoder();
    return textDecoder.decode(value);
  }
  deserializeBytes() {
    const len = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(len));
  }
  deserializeFixedBytes(len) {
    return new Uint8Array(this.read(len));
  }
  deserializeBool() {
    const bool2 = new Uint8Array(this.read(1))[0];
    if (bool2 !== 1 && bool2 !== 0) {
      throw new Error("Invalid boolean value");
    }
    return bool2 === 1;
  }
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  deserializeU64() {
    const low = this.deserializeU32();
    const high = this.deserializeU32();
    return BigInt(BigInt(high) << BigInt(32) | BigInt(low));
  }
  deserializeU128() {
    const low = this.deserializeU64();
    const high = this.deserializeU64();
    return BigInt(high << BigInt(64) | low);
  }
  deserializeU256() {
    const low = this.deserializeU128();
    const high = this.deserializeU128();
    return BigInt(high << BigInt(128) | low);
  }
  deserializeUleb128AsU32() {
    let value = BigInt(0);
    let shift = 0;
    while (value < MAX_U32_NUMBER) {
      const byte = this.deserializeU8();
      value |= BigInt(byte & 127) << BigInt(shift);
      if ((byte & 128) === 0) {
        break;
      }
      shift += 7;
    }
    if (value > MAX_U32_NUMBER) {
      throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    }
    return Number(value);
  }
  deserialize(cls) {
    return cls.deserialize(this);
  }
  deserializeVector(cls) {
    const length = this.deserializeUleb128AsU32();
    const vector = new Array();
    for (let i = 0; i < length; i += 1) {
      vector.push(this.deserialize(cls));
    }
    return vector;
  }
};
var FixedBytes = class extends Serializable {
  constructor(value) {
    super();
    this.value = Hex.fromHexInput(value).toUint8Array();
  }
  serialize(serializer) {
    serializer.serializeFixedBytes(this.value);
  }
  serializeForEntryFunction(serializer) {
    serializer.serialize(this);
  }
  serializeForScriptFunction(serializer) {
    serializer.serialize(this);
  }
  static deserialize(deserializer, length) {
    const bytes2 = deserializer.deserializeFixedBytes(length);
    return new FixedBytes(bytes2);
  }
};
var EntryFunctionBytes = class extends Serializable {
  constructor(value) {
    super();
    this.value = new FixedBytes(value);
  }
  serialize(serializer) {
    serializer.serialize(this.value);
  }
  serializeForEntryFunction(serializer) {
    serializer.serializeU32AsUleb128(this.value.value.length);
    serializer.serialize(this);
  }
  static deserialize(deserializer, length) {
    const fixedBytes = FixedBytes.deserialize(deserializer, length);
    return new EntryFunctionBytes(fixedBytes.value);
  }
};
var Bool = class extends Serializable {
  constructor(value) {
    super();
    ensureBoolean(value);
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeBool(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      5
      /* Bool */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new Bool(deserializer.deserializeBool());
  }
};
var U8 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, 0, MAX_U8_NUMBER);
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU8(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* U8 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U8(deserializer.deserializeU8());
  }
};
var U16 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, 0, MAX_U16_NUMBER);
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU16(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      6
      /* U16 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U16(deserializer.deserializeU16());
  }
};
var U32 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, 0, MAX_U32_NUMBER);
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      7
      /* U32 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U32(deserializer.deserializeU32());
  }
};
var U64 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, BigInt(0), MAX_U64_BIG_INT);
    this.value = BigInt(value);
  }
  serialize(serializer) {
    serializer.serializeU64(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* U64 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U64(deserializer.deserializeU64());
  }
};
var U128 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, BigInt(0), MAX_U128_BIG_INT);
    this.value = BigInt(value);
  }
  serialize(serializer) {
    serializer.serializeU128(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* U128 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U128(deserializer.deserializeU128());
  }
};
var U256 = class extends Serializable {
  constructor(value) {
    super();
    validateNumberInRange(value, BigInt(0), MAX_U256_BIG_INT);
    this.value = BigInt(value);
  }
  serialize(serializer) {
    serializer.serializeU256(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    serializer.serializeU32AsUleb128(
      8
      /* U256 */
    );
    serializer.serialize(this);
  }
  static deserialize(deserializer) {
    return new U256(deserializer.deserializeU256());
  }
};
var MoveVector = class extends Serializable {
  constructor(values) {
    super();
    this.values = values;
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    const isU8 = this.values[0] instanceof U8;
    if (!isU8) {
      throw new Error("Script function arguments only accept u8 vectors");
    }
    serializer.serializeU32AsUleb128(
      4
      /* U8Vector */
    );
    serializer.serialize(this);
  }
  static U8(values) {
    let numbers;
    if (Array.isArray(values) && typeof values[0] === "number") {
      numbers = values;
    } else if (typeof values === "string") {
      const hex = Hex.fromHexInput(values);
      numbers = Array.from(hex.toUint8Array());
    } else if (values instanceof Uint8Array) {
      numbers = Array.from(values);
    } else {
      throw new Error("Invalid input type");
    }
    return new MoveVector(numbers.map((v) => new U8(v)));
  }
  static U16(values) {
    return new MoveVector(values.map((v) => new U16(v)));
  }
  static U32(values) {
    return new MoveVector(values.map((v) => new U32(v)));
  }
  static U64(values) {
    return new MoveVector(values.map((v) => new U64(v)));
  }
  static U128(values) {
    return new MoveVector(values.map((v) => new U128(v)));
  }
  static U256(values) {
    return new MoveVector(values.map((v) => new U256(v)));
  }
  static Bool(values) {
    return new MoveVector(values.map((v) => new Bool(v)));
  }
  static MoveString(values) {
    return new MoveVector(values.map((v) => new MoveString(v)));
  }
  serialize(serializer) {
    serializer.serializeVector(this.values);
  }
  static deserialize(deserializer, cls) {
    const length = deserializer.deserializeUleb128AsU32();
    const values = new Array();
    for (let i = 0; i < length; i += 1) {
      values.push(cls.deserialize(deserializer));
    }
    return new MoveVector(values);
  }
};
var MoveString = class extends Serializable {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeStr(this.value);
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  serializeForScriptFunction(serializer) {
    const vectorU8 = MoveVector.U8(this.bcsToBytes());
    vectorU8.serializeForScriptFunction(serializer);
  }
  static deserialize(deserializer) {
    return new MoveString(deserializer.deserializeStr());
  }
};
var MoveOption = class extends Serializable {
  constructor(value) {
    super();
    if (typeof value !== "undefined" && value !== null) {
      this.vec = new MoveVector([value]);
    } else {
      this.vec = new MoveVector([]);
    }
    [this.value] = this.vec.values;
  }
  serializeForEntryFunction(serializer) {
    const bcsBytes = this.bcsToBytes();
    serializer.serializeBytes(bcsBytes);
  }
  unwrap() {
    if (!this.isSome()) {
      throw new Error("Called unwrap on a MoveOption with no value");
    } else {
      return this.vec.values[0];
    }
  }
  isSome() {
    return this.vec.values.length === 1;
  }
  serialize(serializer) {
    this.vec.serialize(serializer);
  }
  static U8(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U8(value) : void 0);
  }
  static U16(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U16(value) : void 0);
  }
  static U32(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U32(value) : void 0);
  }
  static U64(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U64(value) : void 0);
  }
  static U128(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U128(value) : void 0);
  }
  static U256(value) {
    return new MoveOption(value !== null && value !== void 0 ? new U256(value) : void 0);
  }
  static Bool(value) {
    return new MoveOption(value !== null && value !== void 0 ? new Bool(value) : void 0);
  }
  static MoveString(value) {
    return new MoveOption(value !== null && value !== void 0 ? new MoveString(value) : void 0);
  }
  static deserialize(deserializer, cls) {
    const vector = MoveVector.deserialize(deserializer, cls);
    return new MoveOption(vector.values[0]);
  }
};
var PublicKey = class extends Serializable {
};
var PrivateKey = class extends Serializable {
};
var Signature = class extends Serializable {
};
var _Ed25519PublicKey = class extends PublicKey {
  constructor(hexInput) {
    super();
    const hex = Hex.fromHexInput(hexInput);
    if (hex.toUint8Array().length !== _Ed25519PublicKey.LENGTH) {
      throw new Error(`PublicKey length should be ${_Ed25519PublicKey.LENGTH}`);
    }
    this.key = hex;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  verifySignature(args) {
    const { message, signature } = args;
    const rawMessage = Hex.fromHexInput(message).toUint8Array();
    const rawSignature = Hex.fromHexInput(signature.toUint8Array()).toUint8Array();
    return import_tweetnacl.default.sign.detached.verify(rawMessage, rawSignature, this.key.toUint8Array());
  }
  serialize(serializer) {
    serializer.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Ed25519PublicKey(bytes2);
  }
  static load(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Ed25519PublicKey(bytes2);
  }
};
var Ed25519PublicKey = _Ed25519PublicKey;
Ed25519PublicKey.LENGTH = 32;
var _Ed25519PrivateKey = class extends PrivateKey {
  constructor(hexInput) {
    super();
    const privateKeyHex = Hex.fromHexInput(hexInput);
    if (privateKeyHex.toUint8Array().length !== _Ed25519PrivateKey.LENGTH) {
      throw new Error(`PrivateKey length should be ${_Ed25519PrivateKey.LENGTH}`);
    }
    this.signingKeyPair = import_tweetnacl.default.sign.keyPair.fromSeed(privateKeyHex.toUint8Array().slice(0, _Ed25519PrivateKey.LENGTH));
  }
  toUint8Array() {
    return this.signingKeyPair.secretKey.slice(0, _Ed25519PrivateKey.LENGTH);
  }
  toString() {
    return Hex.fromHexInput(this.toUint8Array()).toString();
  }
  sign(message) {
    const hex = Hex.fromHexInput(message);
    const signature = import_tweetnacl.default.sign.detached(hex.toUint8Array(), this.signingKeyPair.secretKey);
    return new Ed25519Signature(signature);
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Ed25519PrivateKey(bytes2);
  }
  static generate() {
    const keyPair = import_tweetnacl.default.sign.keyPair();
    return new _Ed25519PrivateKey(keyPair.secretKey.slice(0, _Ed25519PrivateKey.LENGTH));
  }
  publicKey() {
    const bytes2 = this.signingKeyPair.publicKey;
    return new Ed25519PublicKey(bytes2);
  }
};
var Ed25519PrivateKey = _Ed25519PrivateKey;
Ed25519PrivateKey.LENGTH = 32;
var _Ed25519Signature = class extends Signature {
  constructor(hexInput) {
    super();
    const hex = Hex.fromHexInput(hexInput);
    if (hex.toUint8Array().length !== _Ed25519Signature.LENGTH) {
      throw new Error(`Signature length should be ${_Ed25519Signature.LENGTH}`);
    }
    this.data = hex;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  toString() {
    return this.data.toString();
  }
  serialize(serializer) {
    serializer.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Ed25519Signature(bytes2);
  }
  static load(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Ed25519Signature(bytes2);
  }
};
var Ed25519Signature = _Ed25519Signature;
Ed25519Signature.LENGTH = 64;
var _MultiEd25519PublicKey = class extends PublicKey {
  constructor(args) {
    super();
    const { publicKeys, threshold } = args;
    if (publicKeys.length > _MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < _MultiEd25519PublicKey.MIN_KEYS) {
      throw new Error(
        `Must have between ${_MultiEd25519PublicKey.MIN_KEYS} and ${_MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`
      );
    }
    if (threshold < _MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {
      throw new Error(
        `Threshold must be between ${_MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`
      );
    }
    this.publicKeys = publicKeys;
    this.threshold = threshold;
  }
  toUint8Array() {
    const bytes2 = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);
    this.publicKeys.forEach((k, i) => {
      bytes2.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);
    });
    bytes2[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;
    return bytes2;
  }
  toString() {
    return Hex.fromHexInput(this.toUint8Array()).toString();
  }
  verifySignature(args) {
    throw new Error("TODO - Method not implemented.");
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    const threshold = bytes2[bytes2.length - 1];
    const keys = [];
    for (let i = 0; i < bytes2.length - 1; i += Ed25519PublicKey.LENGTH) {
      const begin = i;
      keys.push(new Ed25519PublicKey(bytes2.subarray(begin, begin + Ed25519PublicKey.LENGTH)));
    }
    return new _MultiEd25519PublicKey({ publicKeys: keys, threshold });
  }
};
var MultiEd25519PublicKey = _MultiEd25519PublicKey;
MultiEd25519PublicKey.MAX_KEYS = 32;
MultiEd25519PublicKey.MIN_KEYS = 2;
MultiEd25519PublicKey.MIN_THRESHOLD = 1;
var _MultiEd25519Signature = class extends Signature {
  constructor(args) {
    super();
    const { signatures, bitmap } = args;
    if (bitmap.length !== _MultiEd25519Signature.BITMAP_LEN) {
      throw new Error(`"bitmap" length should be ${_MultiEd25519Signature.BITMAP_LEN}`);
    }
    if (signatures.length > _MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {
      throw new Error(
        `The number of signatures cannot be greater than ${_MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`
      );
    }
    this.signatures = signatures;
    this.bitmap = bitmap;
  }
  toUint8Array() {
    const bytes2 = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + _MultiEd25519Signature.BITMAP_LEN);
    this.signatures.forEach((k, i) => {
      bytes2.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);
    });
    bytes2.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);
    return bytes2;
  }
  toString() {
    return Hex.fromHexInput(this.toUint8Array()).toString();
  }
  static createBitmap(args) {
    const { bits } = args;
    const firstBitInByte = 128;
    const bitmap = new Uint8Array([0, 0, 0, 0]);
    const dupCheckSet = /* @__PURE__ */ new Set();
    bits.forEach((bit) => {
      if (bit >= _MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {
        throw new Error(`Cannot have a signature larger than ${_MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);
      }
      if (dupCheckSet.has(bit)) {
        throw new Error("Duplicate bits detected.");
      }
      dupCheckSet.add(bit);
      const byteOffset = Math.floor(bit / 8);
      let byte = bitmap[byteOffset];
      byte |= firstBitInByte >> bit % 8;
      bitmap[byteOffset] = byte;
    });
    return bitmap;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    const bitmap = bytes2.subarray(bytes2.length - 4);
    const signatures = [];
    for (let i = 0; i < bytes2.length - bitmap.length; i += Ed25519Signature.LENGTH) {
      const begin = i;
      signatures.push(new Ed25519Signature(bytes2.subarray(begin, begin + Ed25519Signature.LENGTH)));
    }
    return new _MultiEd25519Signature({ signatures, bitmap });
  }
};
var MultiEd25519Signature = _MultiEd25519Signature;
MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED = 32;
MultiEd25519Signature.BITMAP_LEN = 4;
var _Secp256k1PublicKey = class extends PublicKey {
  constructor(hexInput) {
    super();
    const hex = Hex.fromHexInput(hexInput);
    if (hex.toUint8Array().length !== _Secp256k1PublicKey.LENGTH) {
      throw new Error(`PublicKey length should be ${_Secp256k1PublicKey.LENGTH}`);
    }
    this.key = hex;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  verifySignature(args) {
    const { message, signature } = args;
    const msgHex = Hex.fromHexInput(message).toUint8Array();
    const sha3Message = sha3_256(msgHex);
    const rawSignature = signature.toUint8Array();
    return secp256k1.verify(rawSignature, sha3Message, this.toUint8Array());
  }
  serialize(serializer) {
    serializer.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Secp256k1PublicKey(bytes2);
  }
  static load(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Secp256k1PublicKey(bytes2);
  }
};
var Secp256k1PublicKey = _Secp256k1PublicKey;
Secp256k1PublicKey.LENGTH = 65;
var _Secp256k1PrivateKey = class extends PrivateKey {
  constructor(hexInput) {
    super();
    const privateKeyHex = Hex.fromHexInput(hexInput);
    if (privateKeyHex.toUint8Array().length !== _Secp256k1PrivateKey.LENGTH) {
      throw new Error(`PrivateKey length should be ${_Secp256k1PrivateKey.LENGTH}`);
    }
    this.key = privateKeyHex;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  sign(message) {
    const msgHex = Hex.fromHexInput(message);
    const sha3Message = sha3_256(msgHex.toUint8Array());
    const signature = secp256k1.sign(sha3Message, this.key.toUint8Array());
    return new Secp256k1Signature(signature.toCompactRawBytes());
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Secp256k1PrivateKey(bytes2);
  }
  static generate() {
    const hexInput = secp256k1.utils.randomPrivateKey();
    return new _Secp256k1PrivateKey(hexInput);
  }
  publicKey() {
    const bytes2 = secp256k1.getPublicKey(this.key.toUint8Array(), false);
    return new Secp256k1PublicKey(bytes2);
  }
};
var Secp256k1PrivateKey = _Secp256k1PrivateKey;
Secp256k1PrivateKey.LENGTH = 32;
var _Secp256k1Signature = class extends Signature {
  constructor(hexInput) {
    super();
    const hex = Hex.fromHexInput(hexInput);
    if (hex.toUint8Array().length !== _Secp256k1Signature.LENGTH) {
      throw new Error(`Signature length should be ${_Secp256k1Signature.LENGTH}, recieved ${hex.toUint8Array().length}`);
    }
    this.data = hex;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  toString() {
    return this.data.toString();
  }
  serialize(serializer) {
    serializer.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(deserializer) {
    const hex = deserializer.deserializeBytes();
    return new _Secp256k1Signature(hex);
  }
  static load(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    return new _Secp256k1Signature(bytes2);
  }
};
var Secp256k1Signature = _Secp256k1Signature;
Secp256k1Signature.LENGTH = 64;
var AnyPublicKey = class extends PublicKey {
  constructor(publicKey) {
    super();
    this.publicKey = publicKey;
  }
  toUint8Array() {
    return this.publicKey.toUint8Array();
  }
  toString() {
    return this.publicKey.toString();
  }
  verifySignature(args) {
    const { message, signature } = args;
    return this.publicKey.verifySignature({ message, signature });
  }
  serialize(serializer) {
    if (this.publicKey instanceof Ed25519PublicKey) {
      serializer.serializeU32AsUleb128(
        0
        /* Ed25519 */
      );
      this.publicKey.serialize(serializer);
    } else if (this.publicKey instanceof Secp256k1PublicKey) {
      serializer.serializeU32AsUleb128(
        1
        /* Secp256k1 */
      );
      this.publicKey.serialize(serializer);
    } else {
      throw new Error("Unknown public key type");
    }
  }
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return new AnyPublicKey(Ed25519PublicKey.load(deserializer));
      case 1:
        return new AnyPublicKey(Secp256k1PublicKey.load(deserializer));
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${index}`);
    }
  }
};
var MultiKey = class extends PublicKey {
  constructor(args) {
    super();
    const { publicKeys, signaturesRequired } = args;
    if (signaturesRequired < 1) {
      throw new Error("The number of required signatures needs to be greater then 0");
    }
    if (publicKeys.length < signaturesRequired) {
      throw new Error(
        `Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`
      );
    }
    const keys = [];
    publicKeys.forEach((publicKey) => {
      if (publicKey instanceof AnyPublicKey) {
        keys.push(publicKey);
      } else {
        keys.push(new AnyPublicKey(publicKey));
      }
    });
    this.publicKeys = keys;
    this.signaturesRequired = signaturesRequired;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  createBitmap(args) {
    const { bits } = args;
    const firstBitInByte = 128;
    const bitmap = new Uint8Array([0, 0, 0, 0]);
    const dupCheckSet = /* @__PURE__ */ new Set();
    bits.forEach((bit, idx) => {
      if (idx + 1 > this.publicKeys.length) {
        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);
      }
      if (dupCheckSet.has(bit)) {
        throw new Error(`Duplicate bit ${bit} detected.`);
      }
      dupCheckSet.add(bit);
      const byteOffset = Math.floor(bit / 8);
      let byte = bitmap[byteOffset];
      byte |= firstBitInByte >> bit % 8;
      bitmap[byteOffset] = byte;
    });
    return bitmap;
  }
  toString() {
    return Hex.fromHexInput(this.toUint8Array()).toString();
  }
  verifySignature(args) {
    throw new Error("not implemented");
  }
  serialize(serializer) {
    serializer.serializeVector(this.publicKeys);
    serializer.serializeU8(this.signaturesRequired);
  }
  static deserialize(deserializer) {
    const keys = deserializer.deserializeVector(AnyPublicKey);
    const signaturesRequired = deserializer.deserializeU8();
    return new MultiKey({ publicKeys: keys, signaturesRequired });
  }
};
var _AuthenticationKey = class extends Serializable {
  constructor(args) {
    super();
    const { data } = args;
    const hex = Hex.fromHexInput(data);
    if (hex.toUint8Array().length !== _AuthenticationKey.LENGTH) {
      throw new Error(`Authentication Key length should be ${_AuthenticationKey.LENGTH}`);
    }
    this.data = hex;
  }
  serialize(serializer) {
    serializer.serializeFixedBytes(this.data.toUint8Array());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeFixedBytes(_AuthenticationKey.LENGTH);
    return new _AuthenticationKey({ data: bytes2 });
  }
  toString() {
    return this.data.toString();
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  static fromPublicKeyAndScheme(args) {
    const { publicKey, scheme } = args;
    let authKeyBytes;
    switch (scheme) {
      case 3:
      case 2: {
        const singleKeyBytes = publicKey.bcsToBytes();
        authKeyBytes = new Uint8Array([...singleKeyBytes, scheme]);
        break;
      }
      case 0:
      case 1: {
        const ed25519PublicKeyBytes = publicKey.toUint8Array();
        const inputBytes = Hex.fromHexInput(ed25519PublicKeyBytes).toUint8Array();
        authKeyBytes = new Uint8Array([...inputBytes, scheme]);
        break;
      }
      default:
        throw new Error(`Scheme ${scheme} is not supported`);
    }
    const hash2 = sha3_256.create();
    hash2.update(authKeyBytes);
    const hashDigest = hash2.digest();
    return new _AuthenticationKey({ data: hashDigest });
  }
  static fromPublicKey(args) {
    const { publicKey } = args;
    let scheme;
    if (publicKey instanceof Ed25519PublicKey) {
      scheme = 0 .valueOf();
    } else if (publicKey instanceof MultiEd25519PublicKey) {
      scheme = 1 .valueOf();
    } else if (publicKey instanceof AnyPublicKey) {
      scheme = 2 .valueOf();
    } else if (publicKey instanceof MultiKey) {
      scheme = 3 .valueOf();
    } else {
      throw new Error("No supported authentication scheme for public key");
    }
    return _AuthenticationKey.fromPublicKeyAndScheme({ publicKey, scheme });
  }
  derivedAddress() {
    return new AccountAddress({ data: this.data.toUint8Array() });
  }
};
var AuthenticationKey = _AuthenticationKey;
AuthenticationKey.LENGTH = 32;
var APTOS_PATH_REGEX = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
var KeyType = ((KeyType2) => {
  KeyType2["ED25519"] = "ed25519 seed";
  return KeyType2;
})(KeyType || {});
var HARDENED_OFFSET = 2147483648;
var deriveKey = (hashSeed, data) => {
  const digest = hmac.create(sha512, hashSeed).update(data).digest();
  return {
    key: digest.slice(0, 32),
    chainCode: digest.slice(32)
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const buffer = new ArrayBuffer(4);
  new DataView(buffer).setUint32(0, index);
  const indexBytes = new Uint8Array(buffer);
  const zero = new Uint8Array([0]);
  const data = new Uint8Array([...zero, ...key, ...indexBytes]);
  return deriveKey(chainCode, data);
};
var removeApostrophes = (val) => val.replace("'", "");
var splitPath = (path) => path.split("/").slice(1).map(removeApostrophes);
var isValidPath = (path) => {
  if (!APTOS_PATH_REGEX.test(path)) {
    return false;
  }
  return !splitPath(path).some(Number.isNaN);
};
var mnemonicToSeed = (mnemonic) => {
  const normalizedMnemonic = mnemonic.trim().split(/\s+/).map((part) => part.toLowerCase()).join(" ");
  return bip39.mnemonicToSeedSync(normalizedMnemonic);
};
var derivePrivateKeyFromMnemonic = (keyType, path, seedPhrase, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = deriveKey(keyType, mnemonicToSeed(seedPhrase));
  const segments = splitPath(path).map((el) => parseInt(el, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });
};
var Account = class {
  constructor(args) {
    const { privateKey, address, legacy } = args;
    this.publicKey = privateKey.publicKey();
    if (this.publicKey instanceof Ed25519PublicKey) {
      if (legacy) {
        this.signingScheme = 0;
      } else {
        this.publicKey = new AnyPublicKey(this.publicKey);
        this.signingScheme = 2;
      }
    } else if (this.publicKey instanceof MultiEd25519PublicKey) {
      this.signingScheme = 1;
    } else if (this.publicKey instanceof Secp256k1PublicKey) {
      this.publicKey = new AnyPublicKey(this.publicKey);
      this.signingScheme = 2;
    } else {
      throw new Error("Can not create new Account, unsupported public key type");
    }
    this.privateKey = privateKey;
    this.accountAddress = address;
  }
  static generate(args) {
    let privateKey;
    switch (args == null ? void 0 : args.scheme) {
      case 2:
        privateKey = Secp256k1PrivateKey.generate();
        break;
      default:
        privateKey = Ed25519PrivateKey.generate();
    }
    let publicKey = privateKey.publicKey();
    if (!(args == null ? void 0 : args.legacy)) {
      publicKey = new AnyPublicKey(privateKey.publicKey());
    }
    const address = new AccountAddress({
      data: Account.authKey({
        publicKey
      }).toUint8Array()
    });
    return new Account({ privateKey, address, legacy: args == null ? void 0 : args.legacy });
  }
  static fromPrivateKeyAndAddress(args) {
    const { privateKey, address, legacy } = args;
    return new Account({ privateKey, address, legacy });
  }
  static fromDerivationPath(args) {
    const { path, mnemonic } = args;
    const { key } = derivePrivateKeyFromMnemonic("ed25519 seed", path, mnemonic);
    const privateKey = new Ed25519PrivateKey(key);
    const publicKey = privateKey.publicKey();
    const authKey = Account.authKey({ publicKey });
    const address = new AccountAddress({ data: authKey.toUint8Array() });
    return new Account({ privateKey, address, legacy: true });
  }
  static authKey(args) {
    const { publicKey } = args;
    const authKey = AuthenticationKey.fromPublicKey({ publicKey });
    return authKey.data;
  }
  sign(data) {
    return this.privateKey.sign(data);
  }
  verifySignature(args) {
    const { message, signature } = args;
    const rawMessage = Hex.fromHexInput(message).toUint8Array();
    return this.publicKey.verifySignature({ message: rawMessage, signature });
  }
};
var CurrentTokenOwnershipFieldsFragmentDoc = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var TokenActivitiesFieldsFragmentDoc = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
var GetAccountCoinsCount = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
var GetAccountCoinsData = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
var GetAccountCollectionsWithOwnedTokens = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
var GetAccountOwnedObjects = `
    query getAccountOwnedObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
var GetAccountOwnedTokens = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetAccountOwnedTokensByTokenData = `
    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetAccountOwnedTokensFromCollection = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetAccountTokensCount = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
var GetAccountTransactionsCount = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
var GetChainTopUserTransactions = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
var GetCollectionData = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    max_supply
    mutable_description
    mutable_uri
    table_handle_v1
    token_standard
    total_minted_v2
    uri
  }
}
    `;
var GetCurrentFungibleAssetBalances = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `;
var GetDelegatedStakingActivities = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
var GetEvents = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
  }
}
    `;
var GetFungibleAssetActivities = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `;
var GetFungibleAssetMetadata = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
  }
}
    `;
var GetNumberOfDelegators = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp!, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `;
var GetProcessorStatus = `
    query getProcessorStatus {
  processor_status {
    last_success_version
    processor
    last_updated
  }
}
    `;
var GetTokenActivity = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${TokenActivitiesFieldsFragmentDoc}`;
var GetCurrentTokenOwnership = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetTokenData = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
async function getLedgerInfo(args) {
  const { aptosConfig } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getLedgerInfo",
    path: ""
  });
  return data;
}
async function getBlockByVersion(args) {
  const { aptosConfig, ledgerVersion, options } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getBlockByVersion",
    path: `blocks/by_version/${ledgerVersion}`,
    params: { with_transactions: options == null ? void 0 : options.withTransactions }
  });
  return data;
}
async function getBlockByHeight(args) {
  const { aptosConfig, blockHeight, options } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getBlockByHeight",
    path: `blocks/by_height/${blockHeight}`,
    params: { with_transactions: options == null ? void 0 : options.withTransactions }
  });
  return data;
}
async function getTableItem(args) {
  const { aptosConfig, handle, data, options } = args;
  const response = await postAptosFullNode({
    aptosConfig,
    originMethod: "getTableItem",
    path: `tables/${handle}/item`,
    params: { ledger_version: options == null ? void 0 : options.ledgerVersion },
    body: data
  });
  return response.data;
}
async function view(args) {
  var _a, _b;
  const { aptosConfig, payload, options } = args;
  const { data } = await postAptosFullNode({
    aptosConfig,
    originMethod: "view",
    path: "view",
    params: { ledger_version: options == null ? void 0 : options.ledgerVersion },
    body: {
      function: payload.function,
      type_arguments: (_a = payload.typeArguments) != null ? _a : [],
      arguments: (_b = payload.functionArguments) != null ? _b : []
    }
  });
  return data;
}
async function getChainTopUserTransactions(args) {
  const { aptosConfig, limit } = args;
  const graphqlQuery = {
    query: GetChainTopUserTransactions,
    variables: { limit }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getChainTopUserTransactions"
  });
  return data.user_transactions;
}
async function queryIndexer(args) {
  const { aptosConfig, query, originMethod } = args;
  const { data } = await postAptosIndexer({
    aptosConfig,
    originMethod: originMethod != null ? originMethod : "queryIndexer",
    path: "",
    body: query,
    overrides: { WITH_CREDENTIALS: false }
  });
  return data;
}
async function getProcessorStatuses(args) {
  const { aptosConfig } = args;
  const graphqlQuery = {
    query: GetProcessorStatus
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getProcessorStatuses"
  });
  return data.processor_status;
}
async function getIndexerLastSuccessVersion(args) {
  const response = await getProcessorStatuses({ aptosConfig: args.aptosConfig });
  return response[0].last_success_version;
}
var cache = /* @__PURE__ */ new Map();
function memoizeAsync(func, key, ttlMs) {
  return async (...args) => {
    if (cache.has(key)) {
      const { value, timestamp } = cache.get(key);
      if (ttlMs === void 0 || Date.now() - timestamp <= ttlMs) {
        return value;
      }
    }
    const result = await func(...args);
    cache.set(key, { value: result, timestamp: Date.now() });
    return result;
  };
}
async function getInfo(args) {
  const { aptosConfig, accountAddress } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getInfo",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}`
  });
  return data;
}
async function getModules(args) {
  var _a;
  const { aptosConfig, accountAddress, options } = args;
  return paginateWithCursor({
    aptosConfig,
    originMethod: "getModules",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/modules`,
    params: {
      ledger_version: options == null ? void 0 : options.ledgerVersion,
      start: options == null ? void 0 : options.offset,
      limit: (_a = options == null ? void 0 : options.limit) != null ? _a : 1e3
    }
  });
}
async function getModule(args) {
  var _a;
  if (((_a = args.options) == null ? void 0 : _a.ledgerVersion) !== void 0) {
    return getModuleInner(args);
  }
  return memoizeAsync(
    async () => getModuleInner(args),
    `module-${args.accountAddress}-${args.moduleName}`,
    1e3 * 60 * 5
  )();
}
async function getModuleInner(args) {
  const { aptosConfig, accountAddress, moduleName, options } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getModule",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/module/${moduleName}`,
    params: { ledger_version: options == null ? void 0 : options.ledgerVersion }
  });
  return data;
}
async function getTransactions(args) {
  const { aptosConfig, accountAddress, options } = args;
  return paginateWithCursor({
    aptosConfig,
    originMethod: "getTransactions",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/transactions`,
    params: { start: options == null ? void 0 : options.offset, limit: options == null ? void 0 : options.limit }
  });
}
async function getResources(args) {
  var _a;
  const { aptosConfig, accountAddress, options } = args;
  return paginateWithCursor({
    aptosConfig,
    originMethod: "getResources",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resources`,
    params: {
      ledger_version: options == null ? void 0 : options.ledgerVersion,
      start: options == null ? void 0 : options.offset,
      limit: (_a = options == null ? void 0 : options.limit) != null ? _a : 999
    }
  });
}
async function getResource(args) {
  const { aptosConfig, accountAddress, resourceType, options } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getResource",
    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resource/${resourceType}`,
    params: { ledger_version: options == null ? void 0 : options.ledgerVersion }
  });
  return data.data;
}
async function lookupOriginalAccountAddress(args) {
  const { aptosConfig, authenticationKey, options } = args;
  const resource = await getResource({
    aptosConfig,
    accountAddress: "0x1",
    resourceType: "0x1::account::OriginatingAddress",
    options
  });
  const {
    address_map: { handle }
  } = resource;
  try {
    const originalAddress = await getTableItem({
      aptosConfig,
      handle,
      data: {
        key: Hex.fromHexInput(authenticationKey).toString(),
        key_type: "address",
        value_type: "address"
      },
      options
    });
    return AccountAddress.fromHexInput(originalAddress);
  } catch (err) {
    if (err instanceof AptosApiError && err.data.error_code === "table_item_not_found") {
      return AccountAddress.fromHexInput(authenticationKey);
    }
    throw err;
  }
}
async function getAccountTokensCount(args) {
  const { aptosConfig, accountAddress } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address },
    amount: { _gt: "0" }
  };
  const graphqlQuery = {
    query: GetAccountTokensCount,
    variables: { where_condition: whereCondition }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountTokensCount"
  });
  if (!data.current_token_ownerships_v2_aggregate.aggregate) {
    throw Error("Failed to get the count of account tokens");
  }
  return data.current_token_ownerships_v2_aggregate.aggregate.count;
}
async function getAccountOwnedTokens(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address },
    amount: { _gt: 0 }
  };
  if (options == null ? void 0 : options.tokenStandard) {
    whereCondition.token_standard = { _eq: options == null ? void 0 : options.tokenStandard };
  }
  const graphqlQuery = {
    query: GetAccountOwnedTokens,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountOwnedTokens"
  });
  return data.current_token_ownerships_v2;
}
async function getAccountOwnedTokensFromCollectionAddress(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, collectionAddress, options } = args;
  const ownerAddress = AccountAddress.fromHexInput(accountAddress).toString();
  const collAddress = Hex.fromHexInput(collectionAddress).toString();
  const whereCondition = {
    owner_address: { _eq: ownerAddress },
    current_token_data: { collection_id: { _eq: collAddress } },
    amount: { _gt: 0 }
  };
  if (options == null ? void 0 : options.tokenStandard) {
    whereCondition.token_standard = { _eq: options == null ? void 0 : options.tokenStandard };
  }
  const graphqlQuery = {
    query: GetAccountOwnedTokensFromCollection,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountOwnedTokensFromCollectionAddress"
  });
  return data.current_token_ownerships_v2;
}
async function getAccountCollectionsWithOwnedTokens(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address },
    amount: { _gt: 0 }
  };
  if (options == null ? void 0 : options.tokenStandard) {
    whereCondition.current_collection = {
      token_standard: { _eq: options == null ? void 0 : options.tokenStandard }
    };
  }
  const graphqlQuery = {
    query: GetAccountCollectionsWithOwnedTokens,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountCollectionsWithOwnedTokens"
  });
  return data.current_collection_ownership_v2_view;
}
async function getAccountTransactionsCount(args) {
  const { aptosConfig, accountAddress } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const graphqlQuery = {
    query: GetAccountTransactionsCount,
    variables: { address }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountTransactionsCount"
  });
  if (!data.account_transactions_aggregate.aggregate) {
    throw Error("Failed to get the count of account transactions");
  }
  return data.account_transactions_aggregate.aggregate.count;
}
async function getAccountCoinsData(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address }
  };
  const graphqlQuery = {
    query: GetAccountCoinsData,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountCoinsData"
  });
  return data.current_fungible_asset_balances;
}
async function getAccountCoinsCount(args) {
  const { aptosConfig, accountAddress } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const graphqlQuery = {
    query: GetAccountCoinsCount,
    variables: { address }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountCoinsCount"
  });
  if (!data.current_fungible_asset_balances_aggregate.aggregate) {
    throw Error("Failed to get the count of account coins");
  }
  return data.current_fungible_asset_balances_aggregate.aggregate.count;
}
async function getAccountOwnedObjects(args) {
  var _a, _b;
  const { aptosConfig, accountAddress, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    owner_address: { _eq: address }
  };
  const graphqlQuery = {
    query: GetAccountOwnedObjects,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getAccountOwnedObjects"
  });
  return data.current_objects;
}
async function deriveAccountFromPrivateKey(args) {
  const { aptosConfig, privateKey } = args;
  const publicKey = new AnyPublicKey(privateKey.publicKey());
  if (privateKey instanceof Secp256k1PrivateKey) {
    const authKey = AuthenticationKey.fromPublicKeyAndScheme({
      publicKey,
      scheme: 2
      /* SingleKey */
    });
    const address = new AccountAddress({ data: authKey.toUint8Array() });
    return Account.fromPrivateKeyAndAddress({ privateKey, address });
  }
  if (privateKey instanceof Ed25519PrivateKey) {
    const SingleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKeyAndScheme({
      publicKey,
      scheme: 2
      /* SingleKey */
    });
    const isSingleSenderTransactionAuthenticator = await isAccountExist({
      authKey: SingleSenderTransactionAuthenticatorAuthKey,
      aptosConfig
    });
    if (isSingleSenderTransactionAuthenticator) {
      const address = new AccountAddress({ data: SingleSenderTransactionAuthenticatorAuthKey.toUint8Array() });
      return Account.fromPrivateKeyAndAddress({ privateKey, address });
    }
    const legacyAuthKey = AuthenticationKey.fromPublicKeyAndScheme({
      publicKey,
      scheme: 0
      /* Ed25519 */
    });
    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, aptosConfig });
    if (isLegacyEd25519) {
      const address = new AccountAddress({ data: legacyAuthKey.toUint8Array() });
      return Account.fromPrivateKeyAndAddress({ privateKey, address, legacy: true });
    }
  }
  throw new Error(`Can't derive account from private key ${privateKey}`);
}
async function isAccountExist(args) {
  const { aptosConfig, authKey } = args;
  const accountAddress = await lookupOriginalAccountAddress({
    aptosConfig,
    authenticationKey: authKey.toString()
  });
  try {
    await getInfo({
      aptosConfig,
      accountAddress: accountAddress.toString()
    });
    return true;
  } catch (error) {
    if (error.status === 404) {
      return false;
    }
    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);
  }
}
var Account2 = class {
  constructor(config) {
    this.config = config;
  }
  async getAccountInfo(args) {
    return getInfo({ aptosConfig: this.config, ...args });
  }
  async getAccountModules(args) {
    return getModules({ aptosConfig: this.config, ...args });
  }
  async getAccountModule(args) {
    return getModule({ aptosConfig: this.config, ...args });
  }
  async getAccountTransactions(args) {
    return getTransactions({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountResources(args) {
    return getResources({ aptosConfig: this.config, ...args });
  }
  async getAccountResource(args) {
    return getResource({ aptosConfig: this.config, ...args });
  }
  async lookupOriginalAccountAddress(args) {
    return lookupOriginalAccountAddress({ aptosConfig: this.config, ...args });
  }
  async getAccountTokensCount(args) {
    return getAccountTokensCount({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountOwnedTokens(args) {
    return getAccountOwnedTokens({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountOwnedTokensFromCollectionAddress(args) {
    return getAccountOwnedTokensFromCollectionAddress({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountCollectionsWithOwnedTokens(args) {
    return getAccountCollectionsWithOwnedTokens({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountTransactionsCount(args) {
    return getAccountTransactionsCount({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountCoinsData(args) {
    return getAccountCoinsData({
      aptosConfig: this.config,
      ...args
    });
  }
  async getAccountCoinsCount(args) {
    return getAccountCoinsCount({ aptosConfig: this.config, ...args });
  }
  async getAccountOwnedObjects(args) {
    return getAccountOwnedObjects({
      aptosConfig: this.config,
      ...args
    });
  }
  async deriveAccountFromPrivateKey(args) {
    return deriveAccountFromPrivateKey({ aptosConfig: this.config, ...args });
  }
};
var AptosConfig = class {
  constructor(settings) {
    var _a, _b, _c;
    this.network = (_a = settings == null ? void 0 : settings.network) != null ? _a : DEFAULT_NETWORK;
    this.fullnode = settings == null ? void 0 : settings.fullnode;
    this.faucet = settings == null ? void 0 : settings.faucet;
    this.indexer = settings == null ? void 0 : settings.indexer;
    this.client = (_b = settings == null ? void 0 : settings.client) != null ? _b : { provider: aptosClient };
    this.clientConfig = (_c = settings == null ? void 0 : settings.clientConfig) != null ? _c : {};
  }
  getRequestUrl(apiType) {
    switch (apiType) {
      case 0:
        if (this.fullnode !== void 0)
          return this.fullnode;
        if (this.network === "custom")
          throw new Error("Please provide a custom full node url");
        return NetworkToNodeAPI[this.network];
      case 2:
        if (this.faucet !== void 0)
          return this.faucet;
        if (this.network === "custom")
          throw new Error("Please provide a custom faucet url");
        return NetworkToFaucetAPI[this.network];
      case 1:
        if (this.indexer !== void 0)
          return this.indexer;
        if (this.network === "custom")
          throw new Error("Please provide a custom indexer url");
        return NetworkToIndexerAPI[this.network];
      default:
        throw Error(`apiType ${apiType} is not supported`);
    }
  }
  isIndexerRequest(url) {
    return NetworkToIndexerAPI[this.network] === url;
  }
};
var AnySignature = class extends Signature {
  constructor(signature) {
    super();
    this.signature = signature;
  }
  toUint8Array() {
    return this.signature.toUint8Array();
  }
  toString() {
    return this.signature.toString();
  }
  serialize(serializer) {
    if (this.signature instanceof Ed25519Signature) {
      serializer.serializeU32AsUleb128(
        0
        /* Ed25519 */
      );
      this.signature.serialize(serializer);
    } else if (this.signature instanceof Secp256k1Signature) {
      serializer.serializeU32AsUleb128(
        1
        /* Secp256k1 */
      );
      this.signature.serialize(serializer);
    } else {
      throw new Error("Unknown signature type");
    }
  }
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return new AnySignature(Ed25519Signature.load(deserializer));
      case 1:
        return new AnySignature(Secp256k1Signature.load(deserializer));
      default:
        throw new Error(`Unknown variant index for AnySignature: ${index}`);
    }
  }
};
async function sleep(timeMs) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeMs);
  });
}
async function getTransactions2(args) {
  const { aptosConfig, options } = args;
  return paginateWithCursor({
    aptosConfig,
    originMethod: "getTransactions",
    path: "transactions",
    params: { start: options == null ? void 0 : options.offset, limit: options == null ? void 0 : options.limit }
  });
}
async function getGasPriceEstimation(args) {
  const { aptosConfig } = args;
  return memoizeAsync(
    async () => {
      const { data } = await getAptosFullNode({
        aptosConfig,
        originMethod: "getGasPriceEstimation",
        path: "estimate_gas_price"
      });
      return data;
    },
    `gas-price-${aptosConfig.network}`,
    1e3 * 60 * 5
  )();
}
async function getTransactionByVersion(args) {
  const { aptosConfig, ledgerVersion } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    originMethod: "getTransactionByVersion",
    path: `transactions/by_version/${ledgerVersion}`
  });
  return data;
}
async function getTransactionByHash(args) {
  const { aptosConfig, transactionHash } = args;
  const { data } = await getAptosFullNode({
    aptosConfig,
    path: `transactions/by_hash/${transactionHash}`,
    originMethod: "getTransactionByHash"
  });
  return data;
}
async function isTransactionPending(args) {
  const { aptosConfig, transactionHash } = args;
  try {
    const transaction = await getTransactionByHash({ aptosConfig, transactionHash });
    return transaction.type === "pending_transaction";
  } catch (e) {
    if ((e == null ? void 0 : e.status) === 404) {
      return true;
    }
    throw e;
  }
}
async function waitForTransaction(args) {
  var _a, _b, _c;
  const { aptosConfig, transactionHash, options } = args;
  const timeoutSecs = (_a = options == null ? void 0 : options.timeoutSecs) != null ? _a : DEFAULT_TXN_TIMEOUT_SEC;
  const checkSuccess = (_b = options == null ? void 0 : options.checkSuccess) != null ? _b : true;
  const indexerVersionCheck = (_c = options == null ? void 0 : options.indexerVersionCheck) != null ? _c : true;
  let isPending = true;
  let timeElapsed = 0;
  let lastTxn;
  let lastError;
  let backoffIntervalMs = 200;
  const backoffMultiplier = 1.5;
  while (isPending) {
    if (timeElapsed >= timeoutSecs) {
      break;
    }
    try {
      lastTxn = await getTransactionByHash({ aptosConfig, transactionHash });
      isPending = lastTxn.type === "pending_transaction";
      if (!isPending) {
        break;
      }
    } catch (e) {
      const isAptosApiError = e instanceof AptosApiError;
      if (!isAptosApiError) {
        throw e;
      }
      lastError = e;
      const isRequestError = e.status !== 404 && e.status >= 400 && e.status < 500;
      if (isRequestError) {
        throw e;
      }
    }
    await sleep(backoffIntervalMs);
    timeElapsed += backoffIntervalMs / 1e3;
    backoffIntervalMs *= backoffMultiplier;
  }
  if (lastTxn === void 0) {
    if (lastError) {
      throw lastError;
    } else {
      throw new WaitForTransactionError(
        `Fetching transaction ${transactionHash} failed and timed out after ${timeoutSecs} seconds`,
        lastTxn
      );
    }
  }
  if (lastTxn.type === "pending_transaction") {
    throw new WaitForTransactionError(
      `Transaction ${transactionHash} timed out in pending state after ${timeoutSecs} seconds`,
      lastTxn
    );
  }
  if (!checkSuccess) {
    return lastTxn;
  }
  if (!lastTxn.success) {
    throw new FailedTransactionError(
      `Transaction ${transactionHash} failed with an error: ${lastTxn.vm_status}`,
      lastTxn
    );
  }
  if (indexerVersionCheck) {
    try {
      await waitForLastSuccessIndexerVersionSync({ aptosConfig, ledgerVersion: Number(lastTxn.version) });
    } catch (_e) {
      throw new WaitForTransactionError(
        `Transaction ${transactionHash} committed, but timed out waiting for indexer to sync with ledger version ${lastTxn.version}.You can disable this check by setting \`indexerVersionCheck\` to false in the \`extraArgs\` parameter.`,
        lastTxn
      );
    }
  }
  return lastTxn;
}
async function waitForLastSuccessIndexerVersionSync(args) {
  const { aptosConfig, ledgerVersion } = args;
  const timeoutMilliseconds = 3e3;
  const startTime = (/* @__PURE__ */ new Date()).getTime();
  let indexerVersion = -1;
  while (indexerVersion < ledgerVersion) {
    if ((/* @__PURE__ */ new Date()).getTime() - startTime > timeoutMilliseconds) {
      throw new Error("waitForLastSuccessIndexerVersionSync timeout");
    }
    indexerVersion = await getIndexerLastSuccessVersion({ aptosConfig });
    if (indexerVersion >= ledgerVersion) {
      break;
    }
    await sleep(200);
  }
}
var WaitForTransactionError = class extends Error {
  constructor(message, lastSubmittedTransaction) {
    super(message);
    this.lastSubmittedTransaction = lastSubmittedTransaction;
  }
};
var FailedTransactionError = class extends Error {
  constructor(message, transaction) {
    super(message);
    this.transaction = transaction;
  }
};
var AccountAuthenticator = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return AccountAuthenticatorEd25519.load(deserializer);
      case 1:
        return AccountAuthenticatorMultiEd25519.load(deserializer);
      case 2:
        return AccountAuthenticatorSingleKey.load(deserializer);
      case 3:
        return AccountAuthenticatorMultiKey.load(deserializer);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);
    }
  }
};
var AccountAuthenticatorEd25519 = class extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* Ed25519 */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = Ed25519PublicKey.deserialize(deserializer);
    const signature = Ed25519Signature.deserialize(deserializer);
    return new AccountAuthenticatorEd25519(public_key, signature);
  }
};
var AccountAuthenticatorMultiEd25519 = class extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* MultiEd25519 */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = MultiEd25519PublicKey.deserialize(deserializer);
    const signature = MultiEd25519Signature.deserialize(deserializer);
    return new AccountAuthenticatorMultiEd25519(public_key, signature);
  }
};
var AccountAuthenticatorSingleKey = class extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* SingleKey */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = AnyPublicKey.deserialize(deserializer);
    const signature = AnySignature.deserialize(deserializer);
    return new AccountAuthenticatorSingleKey(public_key, signature);
  }
};
var AccountAuthenticatorMultiKey = class extends AccountAuthenticator {
  constructor(public_keys, signatures, signatures_bitmap) {
    super();
    this.public_keys = public_keys;
    this.signatures = signatures;
    this.signatures_bitmap = signatures_bitmap;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* MultiKey */
    );
    this.public_keys.serialize(serializer);
    serializer.serializeVector(this.signatures);
    serializer.serializeBytes(this.signatures_bitmap);
  }
  static load(deserializer) {
    const public_keys = MultiKey.deserialize(deserializer);
    const signatures = deserializer.deserializeVector(AnySignature);
    const signatures_bitmap = deserializer.deserializeBytes();
    return new AccountAuthenticatorMultiKey(public_keys, signatures, signatures_bitmap);
  }
};
var TransactionAuthenticator = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TransactionAuthenticatorEd25519.load(deserializer);
      case 1:
        return TransactionAuthenticatorMultiEd25519.load(deserializer);
      case 2:
        return TransactionAuthenticatorMultiAgent.load(deserializer);
      case 3:
        return TransactionAuthenticatorFeePayer.load(deserializer);
      case 4:
        return TransactionAuthenticatorSingleSender.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);
    }
  }
};
var TransactionAuthenticatorEd25519 = class extends TransactionAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* Ed25519 */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = Ed25519PublicKey.deserialize(deserializer);
    const signature = Ed25519Signature.deserialize(deserializer);
    return new TransactionAuthenticatorEd25519(public_key, signature);
  }
};
var TransactionAuthenticatorMultiEd25519 = class extends TransactionAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* MultiEd25519 */
    );
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = MultiEd25519PublicKey.deserialize(deserializer);
    const signature = MultiEd25519Signature.deserialize(deserializer);
    return new TransactionAuthenticatorMultiEd25519(public_key, signature);
  }
};
var TransactionAuthenticatorMultiAgent = class extends TransactionAuthenticator {
  constructor(sender, secondary_signer_addresses, secondary_signers) {
    super();
    this.sender = sender;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.secondary_signers = secondary_signers;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* MultiAgent */
    );
    this.sender.serialize(serializer);
    serializer.serializeVector(this.secondary_signer_addresses);
    serializer.serializeVector(this.secondary_signers);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);
    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);
    return new TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);
  }
};
var TransactionAuthenticatorFeePayer = class extends TransactionAuthenticator {
  constructor(sender, secondary_signer_addresses, secondary_signers, fee_payer) {
    super();
    this.sender = sender;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.secondary_signers = secondary_signers;
    this.fee_payer = fee_payer;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* FeePayer */
    );
    this.sender.serialize(serializer);
    serializer.serializeVector(this.secondary_signer_addresses);
    serializer.serializeVector(this.secondary_signers);
    this.fee_payer.address.serialize(serializer);
    this.fee_payer.authenticator.serialize(serializer);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);
    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);
    const address = AccountAddress.deserialize(deserializer);
    const authenticator = AccountAuthenticator.deserialize(deserializer);
    const fee_payer = { address, authenticator };
    return new TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);
  }
};
var TransactionAuthenticatorSingleSender = class extends TransactionAuthenticator {
  constructor(sender) {
    super();
    this.sender = sender;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      4
      /* SingleSender */
    );
    this.sender.serialize(serializer);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    return new TransactionAuthenticatorSingleSender(sender);
  }
};
var ChainId = class extends Serializable {
  constructor(chainId) {
    super();
    this.chainId = chainId;
  }
  serialize(serializer) {
    serializer.serializeU8(this.chainId);
  }
  static deserialize(deserializer) {
    const chainId = deserializer.deserializeU8();
    return new ChainId(chainId);
  }
};
var Identifier = class extends Serializable {
  constructor(identifier) {
    super();
    this.identifier = identifier;
  }
  serialize(serializer) {
    serializer.serializeStr(this.identifier);
  }
  static deserialize(deserializer) {
    const identifier = deserializer.deserializeStr();
    return new Identifier(identifier);
  }
};
var ModuleId = class extends Serializable {
  constructor(address, name) {
    super();
    this.address = address;
    this.name = name;
  }
  static fromStr(moduleId) {
    const parts = moduleId.split("::");
    if (parts.length !== 2) {
      throw new Error("Invalid module id.");
    }
    return new ModuleId(AccountAddress.fromString(parts[0]), new Identifier(parts[1]));
  }
  serialize(serializer) {
    this.address.serialize(serializer);
    this.name.serialize(serializer);
  }
  static deserialize(deserializer) {
    const address = AccountAddress.deserialize(deserializer);
    const name = Identifier.deserialize(deserializer);
    return new ModuleId(address, name);
  }
};
var TypeTag = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TypeTagBool.load(deserializer);
      case 1:
        return TypeTagU8.load(deserializer);
      case 2:
        return TypeTagU64.load(deserializer);
      case 3:
        return TypeTagU128.load(deserializer);
      case 4:
        return TypeTagAddress.load(deserializer);
      case 5:
        return TypeTagSigner.load(deserializer);
      case 6:
        return TypeTagVector.load(deserializer);
      case 7:
        return TypeTagStruct.load(deserializer);
      case 8:
        return TypeTagU16.load(deserializer);
      case 9:
        return TypeTagU32.load(deserializer);
      case 10:
        return TypeTagU256.load(deserializer);
      case 255:
        return TypeTagGeneric.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${index}`);
    }
  }
  isBool() {
    return this instanceof TypeTagBool;
  }
  isAddress() {
    return this instanceof TypeTagAddress;
  }
  isGeneric() {
    return this instanceof TypeTagGeneric;
  }
  isSigner() {
    return this instanceof TypeTagSigner;
  }
  isVector() {
    return this instanceof TypeTagVector;
  }
  isStruct() {
    return this instanceof TypeTagStruct;
  }
  isU8() {
    return this instanceof TypeTagU8;
  }
  isU16() {
    return this instanceof TypeTagU16;
  }
  isU32() {
    return this instanceof TypeTagU32;
  }
  isU64() {
    return this instanceof TypeTagU64;
  }
  isU128() {
    return this instanceof TypeTagU128;
  }
  isU256() {
    return this instanceof TypeTagU256;
  }
};
var TypeTagBool = class extends TypeTag {
  toString() {
    return "bool";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* Bool */
    );
  }
  static load(_deserializer) {
    return new TypeTagBool();
  }
};
var TypeTagU8 = class extends TypeTag {
  toString() {
    return "u8";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* U8 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU8();
  }
};
var TypeTagU16 = class extends TypeTag {
  toString() {
    return "u16";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      8
      /* U16 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU16();
  }
};
var TypeTagU32 = class extends TypeTag {
  toString() {
    return "u32";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      9
      /* U32 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU32();
  }
};
var TypeTagU64 = class extends TypeTag {
  toString() {
    return "u64";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* U64 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU64();
  }
};
var TypeTagU128 = class extends TypeTag {
  toString() {
    return "u128";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* U128 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU128();
  }
};
var TypeTagU256 = class extends TypeTag {
  toString() {
    return "u256";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      10
      /* U256 */
    );
  }
  static load(_deserializer) {
    return new TypeTagU256();
  }
};
var TypeTagAddress = class extends TypeTag {
  toString() {
    return "address";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      4
      /* Address */
    );
  }
  static load(_deserializer) {
    return new TypeTagAddress();
  }
};
var TypeTagSigner = class extends TypeTag {
  toString() {
    return "signer";
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      5
      /* Signer */
    );
  }
  static load(_deserializer) {
    return new TypeTagSigner();
  }
};
var TypeTagReference = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return `&${this.value.toString()}`;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      254
      /* Reference */
    );
  }
  static load(deserializer) {
    const value = TypeTag.deserialize(deserializer);
    return new TypeTagReference(value);
  }
};
var TypeTagGeneric = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return `T${this.value}`;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      255
      /* Generic */
    );
    serializer.serializeU32(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU32();
    return new TypeTagGeneric(value);
  }
};
var TypeTagVector = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return `vector<${this.value.toString()}>`;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      6
      /* Vector */
    );
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = TypeTag.deserialize(deserializer);
    return new TypeTagVector(value);
  }
};
var TypeTagStruct = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    let typePredicate = "";
    if (this.value.type_args.length > 0) {
      typePredicate = `<${this.value.type_args.map((typeArg) => typeArg.toString()).join(", ")}>`;
    }
    return `${this.value.address.toString()}::${this.value.module_name.identifier}::${this.value.name.identifier}${typePredicate}`;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      7
      /* Struct */
    );
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = StructTag.deserialize(deserializer);
    return new TypeTagStruct(value);
  }
  isTypeTag(address, moduleName, structName) {
    return this.value.module_name.identifier === moduleName && this.value.name.identifier === structName && this.value.address.equals(address);
  }
  isString() {
    return this.isTypeTag(AccountAddress.ONE, "string", "String");
  }
  isOption() {
    return this.isTypeTag(AccountAddress.ONE, "option", "Option");
  }
  isObject() {
    return this.isTypeTag(AccountAddress.ONE, "object", "Object");
  }
};
var StructTag = class extends Serializable {
  constructor(address, module_name, name, type_args) {
    super();
    this.address = address;
    this.module_name = module_name;
    this.name = name;
    this.type_args = type_args;
  }
  serialize(serializer) {
    serializer.serialize(this.address);
    serializer.serialize(this.module_name);
    serializer.serialize(this.name);
    serializer.serializeVector(this.type_args);
  }
  static deserialize(deserializer) {
    const address = AccountAddress.deserialize(deserializer);
    const moduleName = Identifier.deserialize(deserializer);
    const name = Identifier.deserialize(deserializer);
    const typeArgs = deserializer.deserializeVector(TypeTag);
    return new StructTag(address, moduleName, name, typeArgs);
  }
};
function deserializeFromScriptArgument(deserializer) {
  const index = deserializer.deserializeUleb128AsU32();
  switch (index) {
    case 0:
      return U8.deserialize(deserializer);
    case 1:
      return U64.deserialize(deserializer);
    case 2:
      return U128.deserialize(deserializer);
    case 3:
      return AccountAddress.deserialize(deserializer);
    case 4:
      return MoveVector.deserialize(deserializer, U8);
    case 5:
      return Bool.deserialize(deserializer);
    case 6:
      return U16.deserialize(deserializer);
    case 7:
      return U32.deserialize(deserializer);
    case 8:
      return U256.deserialize(deserializer);
    default:
      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);
  }
}
var TransactionPayload = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TransactionPayloadScript.load(deserializer);
      case 2:
        return TransactionPayloadEntryFunction.load(deserializer);
      case 3:
        return TransactionPayloadMultisig.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);
    }
  }
};
var TransactionPayloadScript = class extends TransactionPayload {
  constructor(script) {
    super();
    this.script = script;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* Script */
    );
    this.script.serialize(serializer);
  }
  static load(deserializer) {
    const script = Script.deserialize(deserializer);
    return new TransactionPayloadScript(script);
  }
};
var TransactionPayloadEntryFunction = class extends TransactionPayload {
  constructor(entryFunction) {
    super();
    this.entryFunction = entryFunction;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      2
      /* EntryFunction */
    );
    this.entryFunction.serialize(serializer);
  }
  static load(deserializer) {
    const entryFunction = EntryFunction.deserialize(deserializer);
    return new TransactionPayloadEntryFunction(entryFunction);
  }
};
var TransactionPayloadMultisig = class extends TransactionPayload {
  constructor(multiSig) {
    super();
    this.multiSig = multiSig;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      3
      /* Multisig */
    );
    this.multiSig.serialize(serializer);
  }
  static load(deserializer) {
    const multiSig = MultiSig.deserialize(deserializer);
    return new TransactionPayloadMultisig(multiSig);
  }
};
var EntryFunction = class {
  constructor(module_name, function_name, type_args, args) {
    this.module_name = module_name;
    this.function_name = function_name;
    this.type_args = type_args;
    this.args = args;
  }
  static build(module_id, function_name, type_args, args) {
    return new EntryFunction(ModuleId.fromStr(module_id), new Identifier(function_name), type_args, args);
  }
  serialize(serializer) {
    this.module_name.serialize(serializer);
    this.function_name.serialize(serializer);
    serializer.serializeVector(this.type_args);
    serializer.serializeU32AsUleb128(this.args.length);
    this.args.forEach((item) => {
      item.serializeForEntryFunction(serializer);
    });
  }
  static deserialize(deserializer) {
    const module_name = ModuleId.deserialize(deserializer);
    const function_name = Identifier.deserialize(deserializer);
    const type_args = deserializer.deserializeVector(TypeTag);
    const length = deserializer.deserializeUleb128AsU32();
    const args = new Array();
    for (let i = 0; i < length; i += 1) {
      const fixedBytesLength = deserializer.deserializeUleb128AsU32();
      const fixedBytes = EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);
      args.push(fixedBytes);
    }
    return new EntryFunction(module_name, function_name, type_args, args);
  }
};
var Script = class {
  constructor(bytecode, type_args, args) {
    this.bytecode = bytecode;
    this.type_args = type_args;
    this.args = args;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.bytecode);
    serializer.serializeVector(this.type_args);
    serializer.serializeU32AsUleb128(this.args.length);
    this.args.forEach((item) => {
      item.serializeForScriptFunction(serializer);
    });
  }
  static deserialize(deserializer) {
    const bytecode = deserializer.deserializeBytes();
    const type_args = deserializer.deserializeVector(TypeTag);
    const length = deserializer.deserializeUleb128AsU32();
    const args = new Array();
    for (let i = 0; i < length; i += 1) {
      const scriptArgument = deserializeFromScriptArgument(deserializer);
      args.push(scriptArgument);
    }
    return new Script(bytecode, type_args, args);
  }
};
var MultiSig = class {
  constructor(multisig_address, transaction_payload) {
    this.multisig_address = multisig_address;
    this.transaction_payload = transaction_payload;
  }
  serialize(serializer) {
    this.multisig_address.serialize(serializer);
    if (this.transaction_payload === void 0) {
      serializer.serializeBool(false);
    } else {
      serializer.serializeBool(true);
      this.transaction_payload.serialize(serializer);
    }
  }
  static deserialize(deserializer) {
    const multisig_address = AccountAddress.deserialize(deserializer);
    const payloadPresent = deserializer.deserializeBool();
    let transaction_payload;
    if (payloadPresent) {
      transaction_payload = MultisigTransactionPayload.deserialize(deserializer);
    }
    return new MultiSig(multisig_address, transaction_payload);
  }
};
var MultisigTransactionPayload = class {
  constructor(transaction_payload) {
    this.transaction_payload = transaction_payload;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.transaction_payload.serialize(serializer);
  }
  static deserialize(deserializer) {
    deserializer.deserializeUleb128AsU32();
    return new MultisigTransactionPayload(EntryFunction.deserialize(deserializer));
  }
};
var RawTransaction = class extends Serializable {
  constructor(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id) {
    super();
    this.sender = sender;
    this.sequence_number = sequence_number;
    this.payload = payload;
    this.max_gas_amount = max_gas_amount;
    this.gas_unit_price = gas_unit_price;
    this.expiration_timestamp_secs = expiration_timestamp_secs;
    this.chain_id = chain_id;
  }
  serialize(serializer) {
    this.sender.serialize(serializer);
    serializer.serializeU64(this.sequence_number);
    this.payload.serialize(serializer);
    serializer.serializeU64(this.max_gas_amount);
    serializer.serializeU64(this.gas_unit_price);
    serializer.serializeU64(this.expiration_timestamp_secs);
    this.chain_id.serialize(serializer);
  }
  static deserialize(deserializer) {
    const sender = AccountAddress.deserialize(deserializer);
    const sequence_number = deserializer.deserializeU64();
    const payload = TransactionPayload.deserialize(deserializer);
    const max_gas_amount = deserializer.deserializeU64();
    const gas_unit_price = deserializer.deserializeU64();
    const expiration_timestamp_secs = deserializer.deserializeU64();
    const chain_id = ChainId.deserialize(deserializer);
    return new RawTransaction(
      sender,
      sequence_number,
      payload,
      max_gas_amount,
      gas_unit_price,
      expiration_timestamp_secs,
      chain_id
    );
  }
};
var RawTransactionWithData = class extends Serializable {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return MultiAgentRawTransaction.load(deserializer);
      case 1:
        return FeePayerRawTransaction.load(deserializer);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);
    }
  }
};
var MultiAgentRawTransaction = class extends RawTransactionWithData {
  constructor(raw_txn, secondary_signer_addresses) {
    super();
    this.raw_txn = raw_txn;
    this.secondary_signer_addresses = secondary_signer_addresses;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      0
      /* MultiAgentTransaction */
    );
    this.raw_txn.serialize(serializer);
    serializer.serializeVector(this.secondary_signer_addresses);
  }
  static load(deserializer) {
    const rawTxn = RawTransaction.deserialize(deserializer);
    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);
    return new MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);
  }
};
var FeePayerRawTransaction = class extends RawTransactionWithData {
  constructor(raw_txn, secondary_signer_addresses, fee_payer_address) {
    super();
    this.raw_txn = raw_txn;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.fee_payer_address = fee_payer_address;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(
      1
      /* FeePayerTransaction */
    );
    this.raw_txn.serialize(serializer);
    serializer.serializeVector(this.secondary_signer_addresses);
    this.fee_payer_address.serialize(serializer);
  }
  static load(deserializer) {
    const rawTxn = RawTransaction.deserialize(deserializer);
    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);
    const feePayerAddress = AccountAddress.deserialize(deserializer);
    return new FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);
  }
};
var SignedTransaction = class extends Serializable {
  constructor(raw_txn, authenticator) {
    super();
    this.raw_txn = raw_txn;
    this.authenticator = authenticator;
  }
  serialize(serializer) {
    this.raw_txn.serialize(serializer);
    this.authenticator.serialize(serializer);
  }
  static deserialize(deserializer) {
    const raw_txn = RawTransaction.deserialize(deserializer);
    const authenticator = TransactionAuthenticator.deserialize(deserializer);
    return new SignedTransaction(raw_txn, authenticator);
  }
};
function isValidIdentifier(str) {
  return !!str.match(/^[_a-zA-Z0-9]+$/);
}
function isValidWhitespaceCharacter(char) {
  return !!char.match(/\s/);
}
function consumeWhitespace(tagStr, pos) {
  let i = pos;
  for (; i < tagStr.length; i += 1) {
    const innerChar = tagStr[i];
    if (!isValidWhitespaceCharacter(innerChar)) {
      break;
    }
  }
  return i;
}
var TypeTagParserErrorType = ((TypeTagParserErrorType2) => {
  TypeTagParserErrorType2["InvalidTypeTag"] = "unknown type";
  TypeTagParserErrorType2["UnexpectedTypeArgumentClose"] = "unexpected '>'";
  TypeTagParserErrorType2["UnexpectedWhitespaceCharacter"] = "unexpected whitespace character";
  TypeTagParserErrorType2["UnexpectedComma"] = "unexpected ','";
  TypeTagParserErrorType2["TypeArgumentCountMismatch"] = "type argument count doesn't match expected amount";
  TypeTagParserErrorType2["MissingTypeArgumentClose"] = "no matching '>' for '<'";
  TypeTagParserErrorType2["UnexpectedPrimitiveTypeArguments"] = "primitive types not expected to have type arguments";
  TypeTagParserErrorType2["UnexpectedVectorTypeArgumentCount"] = "vector type expected to have exactly one type argument";
  TypeTagParserErrorType2["UnexpectedStructFormat"] = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name";
  TypeTagParserErrorType2["InvalidModuleNameCharacter"] = "module name must only contain alphanumeric or '_' characters";
  TypeTagParserErrorType2["InvalidStructNameCharacter"] = "struct name must only contain alphanumeric or '_' characters";
  return TypeTagParserErrorType2;
})(TypeTagParserErrorType || {});
var TypeTagParserError = class extends Error {
  constructor(typeTagStr, invalidReason) {
    super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);
  }
};
function parseTypeTag(typeStr, options) {
  var _a;
  const allowGenerics = (_a = options == null ? void 0 : options.allowGenerics) != null ? _a : false;
  const saved = [];
  let innerTypes = [];
  let curTypes = [];
  let cur = 0;
  let currentStr = "";
  let expectedTypes = 1;
  while (cur < typeStr.length) {
    const char = typeStr[cur];
    if (char === "<") {
      saved.push({
        savedExpectedTypes: expectedTypes,
        savedStr: currentStr,
        savedTypes: curTypes
      });
      currentStr = "";
      curTypes = [];
      expectedTypes = 1;
    } else if (char === ">") {
      if (currentStr !== "") {
        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
        curTypes.push(newType);
      }
      const savedPop = saved.pop();
      if (savedPop === void 0) {
        throw new TypeTagParserError(
          typeStr,
          "unexpected '>'"
          /* UnexpectedTypeArgumentClose */
        );
      }
      if (expectedTypes !== curTypes.length) {
        throw new TypeTagParserError(
          typeStr,
          "type argument count doesn't match expected amount"
          /* TypeArgumentCountMismatch */
        );
      }
      const { savedStr, savedTypes, savedExpectedTypes } = savedPop;
      innerTypes = curTypes;
      curTypes = savedTypes;
      currentStr = savedStr;
      expectedTypes = savedExpectedTypes;
    } else if (char === ",") {
      if (currentStr.length !== 0) {
        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
        innerTypes = [];
        curTypes.push(newType);
        currentStr = "";
        expectedTypes += 1;
      }
    } else if (isValidWhitespaceCharacter(char)) {
      let parsedTypeTag = false;
      if (currentStr.length !== 0) {
        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
        innerTypes = [];
        curTypes.push(newType);
        currentStr = "";
        parsedTypeTag = true;
      }
      cur = consumeWhitespace(typeStr, cur);
      const nextChar = typeStr[cur];
      if (cur < typeStr.length && parsedTypeTag && nextChar !== "," && nextChar !== ">") {
        throw new TypeTagParserError(
          typeStr,
          "unexpected whitespace character"
          /* UnexpectedWhitespaceCharacter */
        );
      }
      continue;
    } else {
      currentStr += char;
    }
    cur += 1;
  }
  if (saved.length > 0) {
    throw new TypeTagParserError(
      typeStr,
      "no matching '>' for '<'"
      /* MissingTypeArgumentClose */
    );
  }
  switch (curTypes.length) {
    case 0:
      return parseTypeTagInner(currentStr, innerTypes, allowGenerics);
    case 1:
      if (currentStr === "") {
        return curTypes[0];
      }
      throw new TypeTagParserError(
        typeStr,
        "unexpected ','"
        /* UnexpectedComma */
      );
    default:
      throw new TypeTagParserError(
        typeStr,
        "unexpected whitespace character"
        /* UnexpectedWhitespaceCharacter */
      );
  }
}
function parseTypeTagInner(str, types, allowGenerics) {
  switch (str) {
    case "&signer":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagReference(new TypeTagSigner());
    case "signer":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagSigner();
    case "bool":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagBool();
    case "address":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagAddress();
    case "u8":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU8();
    case "u16":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU16();
    case "u32":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU32();
    case "u64":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU64();
    case "u128":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU128();
    case "u256":
      if (types.length > 0) {
        throw new TypeTagParserError(
          str,
          "primitive types not expected to have type arguments"
          /* UnexpectedPrimitiveTypeArguments */
        );
      }
      return new TypeTagU256();
    case "vector":
      if (types.length !== 1) {
        throw new TypeTagParserError(
          str,
          "vector type expected to have exactly one type argument"
          /* UnexpectedVectorTypeArgumentCount */
        );
      }
      return new TypeTagVector(types[0]);
    default:
      if (allowGenerics && str.match(/^T[0-9]+$/)) {
        return new TypeTagGeneric(Number(str.split("T")[1]));
      }
      if (!str.match(/.*:.*/)) {
        throw new TypeTagParserError(
          str,
          "unknown type"
          /* InvalidTypeTag */
        );
      }
      const structParts = str.split("::");
      if (structParts.length !== 3) {
        throw new TypeTagParserError(
          str,
          "unexpected struct format, must be of the form 0xaddress::module_name::struct_name"
          /* UnexpectedStructFormat */
        );
      }
      if (!isValidIdentifier(structParts[1])) {
        throw new TypeTagParserError(
          str,
          "module name must only contain alphanumeric or '_' characters"
          /* InvalidModuleNameCharacter */
        );
      }
      if (!isValidIdentifier(structParts[2])) {
        throw new TypeTagParserError(
          str,
          "struct name must only contain alphanumeric or '_' characters"
          /* InvalidStructNameCharacter */
        );
      }
      return new TypeTagStruct(
        new StructTag(
          AccountAddress.fromString(structParts[0]),
          new Identifier(structParts[1]),
          new Identifier(structParts[2]),
          types
        )
      );
  }
}
function isBool(arg) {
  return typeof arg === "boolean";
}
function isString(arg) {
  return typeof arg === "string";
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isLargeNumber(arg) {
  return typeof arg === "number" || typeof arg === "bigint" || typeof arg === "string";
}
function isNull(arg) {
  return arg === null || arg === void 0;
}
function isBcsBool(arg) {
  return arg instanceof Bool;
}
function isBcsAddress(arg) {
  return arg instanceof AccountAddress;
}
function isBcsString(arg) {
  return arg instanceof MoveString;
}
function isBcsFixedBytes(arg) {
  return arg instanceof FixedBytes;
}
function isBcsU8(arg) {
  return arg instanceof U8;
}
function isBcsU16(arg) {
  return arg instanceof U16;
}
function isBcsU32(arg) {
  return arg instanceof U32;
}
function isBcsU64(arg) {
  return arg instanceof U64;
}
function isBcsU128(arg) {
  return arg instanceof U128;
}
function isBcsU256(arg) {
  return arg instanceof U256;
}
function isScriptDataInput(arg) {
  return "bytecode" in arg;
}
function throwTypeMismatch(expectedType, position) {
  throw new Error(`Type mismatch for argument ${position}, expected '${expectedType}'`);
}
function findFirstNonSignerArg(functionAbi) {
  return functionAbi.params.findIndex((param) => param !== "signer" && param !== "&signer");
}
function getFunctionParts(functionArg) {
  const funcNameParts = functionArg.split("::");
  if (funcNameParts.length !== 3) {
    throw new Error(`Invalid function ${functionArg}`);
  }
  const moduleAddress = funcNameParts[0];
  const moduleName = funcNameParts[1];
  const functionName = funcNameParts[2];
  return { moduleAddress, moduleName, functionName };
}
function standardizeTypeTags(typeArguments) {
  var _a;
  return (_a = typeArguments == null ? void 0 : typeArguments.map((typeArg) => {
    if (isString(typeArg)) {
      return parseTypeTag(typeArg);
    }
    return typeArg;
  })) != null ? _a : [];
}
async function fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig) {
  var _a;
  const module = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });
  const functionAbi = (_a = module.abi) == null ? void 0 : _a.exposed_functions.find((func) => func.name === functionName);
  if (!functionAbi) {
    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);
  }
  if (!functionAbi.is_entry) {
    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);
  }
  const first = findFirstNonSignerArg(functionAbi);
  const params = [];
  for (let i = first; i < functionAbi.params.length; i += 1) {
    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));
  }
  return {
    typeParameters: functionAbi.generic_type_params,
    parameters: params
  };
}
function convertArgument(functionName, functionAbi, arg, position, genericTypeParams) {
  if (position >= functionAbi.parameters.length) {
    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);
  }
  if (isBcsBool(arg) || isBcsU8(arg) || isBcsU16(arg) || isBcsU32(arg) || isBcsU64(arg) || isBcsU128(arg) || isBcsU256(arg) || isBcsAddress(arg) || isBcsString(arg) || isBcsFixedBytes(arg) || arg instanceof MoveVector || arg instanceof MoveOption) {
    checkType(functionAbi, arg, position);
    return arg;
  }
  return parseArg(arg, functionAbi.parameters[position], position, genericTypeParams);
}
function parseArg(arg, param, position, genericTypeParams) {
  if (param.isBool()) {
    if (isBool(arg)) {
      return new Bool(arg);
    }
    throwTypeMismatch("boolean", position);
  }
  if (param.isAddress()) {
    if (isString(arg)) {
      return AccountAddress.fromString(arg);
    }
    throwTypeMismatch("string", position);
  }
  if (param.isU8()) {
    if (isNumber(arg)) {
      return new U8(arg);
    }
    throwTypeMismatch("number", position);
  }
  if (param.isU16()) {
    if (isNumber(arg)) {
      return new U16(arg);
    }
    throwTypeMismatch("number", position);
  }
  if (param.isU32()) {
    if (isNumber(arg)) {
      return new U32(arg);
    }
    throwTypeMismatch("number", position);
  }
  if (param.isU64()) {
    if (isLargeNumber(arg)) {
      return new U64(BigInt(arg));
    }
    throwTypeMismatch("bigint | number | string", position);
  }
  if (param.isU128()) {
    if (isLargeNumber(arg)) {
      return new U128(BigInt(arg));
    }
    throwTypeMismatch("bigint | number | string", position);
  }
  if (param.isU256()) {
    if (isLargeNumber(arg)) {
      return new U256(BigInt(arg));
    }
    throwTypeMismatch("bigint | number | string", position);
  }
  if (param.isGeneric()) {
    const genericIndex = param.value;
    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {
      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);
    }
    parseArg(arg, genericTypeParams[genericIndex], position, genericTypeParams);
  }
  if (param.isVector()) {
    if (param.value.isU8() && isString(arg)) {
      return MoveVector.U8(Hex.fromHexInput(arg).toUint8Array());
    }
    if (Array.isArray(arg)) {
      return new MoveVector(arg.map((item) => parseArg(item, param.value, position, genericTypeParams)));
    }
    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);
  }
  if (param.isStruct()) {
    if (param.isString()) {
      if (isString(arg)) {
        return new MoveString(arg);
      }
      throwTypeMismatch("string", position);
    }
    if (param.isObject()) {
      if (isString(arg)) {
        return AccountAddress.fromString(arg);
      }
      throwTypeMismatch("string", position);
    }
    if (param.isOption()) {
      if (isNull(arg)) {
        return new MoveOption(null);
      }
      return new MoveOption(parseArg(arg, param.value.type_args[0], position, genericTypeParams));
    }
    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);
  }
  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);
}
function checkType(functionAbi, arg, position) {
  const param = functionAbi.parameters[position];
  if (param.isBool()) {
    if (isBcsBool(arg)) {
      return;
    }
    throwTypeMismatch("Bool", position);
  }
  if (param.isAddress()) {
    if (isBcsAddress(arg)) {
      return;
    }
    throwTypeMismatch("AccountAddress", position);
  }
  if (param.isU8()) {
    if (isBcsU8(arg)) {
      return;
    }
    throwTypeMismatch("U8", position);
  }
  if (param.isU16()) {
    if (isBcsU16(arg)) {
      return;
    }
    throwTypeMismatch("U16", position);
  }
  if (param.isU32()) {
    if (isBcsU32(arg)) {
      return;
    }
    throwTypeMismatch("U32", position);
  }
  if (param.isU64()) {
    if (isBcsU64(arg)) {
      return;
    }
    throwTypeMismatch("U64", position);
  }
  if (param.isU128()) {
    if (isBcsU128(arg)) {
      return;
    }
    throwTypeMismatch("U128", position);
  }
  if (param.isU256()) {
    if (isBcsU256(arg)) {
      return;
    }
    throwTypeMismatch("U256", position);
  }
  if (param.isVector()) {
    if (arg instanceof MoveVector) {
      return;
    }
    throwTypeMismatch("MoveVector", position);
  }
  if (param instanceof TypeTagStruct) {
    if (param.isString()) {
      if (isBcsString(arg)) {
        return;
      }
      throwTypeMismatch("MoveString", position);
    }
    if (param.isObject()) {
      if (isBcsAddress(arg)) {
        return;
      }
      throwTypeMismatch("AccountAddress", position);
    }
    if (param.isOption()) {
      if (arg instanceof MoveOption) {
        return;
      }
      throwTypeMismatch("MoveOption", position);
    }
  }
  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);
}
async function generateTransactionPayload(args) {
  if (isScriptDataInput(args)) {
    return generateTransactionPayloadScript(args);
  }
  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);
  const functionAbi = await memoizeAsync(
    async () => fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, args.aptosConfig),
    `entry-function-${args.aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`,
    1e3 * 60 * 5
  )();
  return generateTransactionPayloadWithABI(args, functionAbi);
}
function generateTransactionPayloadWithABI(args, functionAbi) {
  if (isScriptDataInput(args)) {
    return generateTransactionPayloadScript(args);
  }
  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);
  const typeArguments = standardizeTypeTags(args.typeArguments);
  if (typeArguments.length !== functionAbi.typeParameters.length) {
    throw new Error(
      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`
    );
  }
  const functionArguments = args.functionArguments.map(
    (arg, i) => convertArgument(args.function, functionAbi, arg, i, typeArguments)
  );
  if (functionArguments.length !== functionAbi.parameters.length) {
    throw new Error(
      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`
    );
  }
  const entryFunctionPayload = EntryFunction.build(
    `${moduleAddress}::${moduleName}`,
    functionName,
    typeArguments,
    functionArguments
  );
  if ("multisigAddress" in args) {
    let multisigAddress;
    if (typeof args.multisigAddress === "string") {
      multisigAddress = AccountAddress.fromString(args.multisigAddress);
    } else {
      multisigAddress = args.multisigAddress;
    }
    return new TransactionPayloadMultisig(
      new MultiSig(multisigAddress, new MultisigTransactionPayload(entryFunctionPayload))
    );
  }
  return new TransactionPayloadEntryFunction(entryFunctionPayload);
}
function generateTransactionPayloadScript(args) {
  var _a;
  return new TransactionPayloadScript(
    new Script(Hex.fromHexInput(args.bytecode).toUint8Array(), (_a = args.typeArguments) != null ? _a : [], args.functionArguments)
  );
}
async function generateRawTransaction(args) {
  const { aptosConfig, sender, payload, options } = args;
  const getSequenceNumber = (options == null ? void 0 : options.accountSequenceNumber) ? Promise.resolve({ sequence_number: options.accountSequenceNumber }) : getInfo({ aptosConfig, accountAddress: sender });
  const getChainId = NetworkToChainId[aptosConfig.network] ? Promise.resolve({ chain_id: NetworkToChainId[aptosConfig.network] }) : getLedgerInfo({ aptosConfig });
  const getGasUnitPrice = (options == null ? void 0 : options.gasUnitPrice) ? Promise.resolve({ gas_estimate: options.gasUnitPrice }) : getGasPriceEstimation({ aptosConfig });
  const [{ sequence_number: sequenceNumber }, { chain_id: chainId }, { gas_estimate: gasEstimate }] = await Promise.all(
    [getSequenceNumber, getChainId, getGasUnitPrice]
  );
  const { maxGasAmount, gasUnitPrice, expireTimestamp } = {
    maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),
    gasUnitPrice: BigInt(gasEstimate),
    expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + DEFAULT_TXN_EXP_SEC_FROM_NOW),
    ...options
  };
  return new RawTransaction(
    AccountAddress.fromHexInput(sender),
    BigInt(sequenceNumber),
    payload,
    BigInt(maxGasAmount),
    BigInt(gasUnitPrice),
    BigInt(expireTimestamp),
    new ChainId(chainId)
  );
}
async function buildTransaction(args) {
  const { aptosConfig, sender, payload, options, secondarySignerAddresses, feePayerAddress } = args;
  const rawTxn = await generateRawTransaction({
    aptosConfig,
    sender,
    payload,
    options
  });
  if (feePayerAddress) {
    const signers = secondarySignerAddresses ? secondarySignerAddresses.map((signer) => AccountAddress.fromHexInput(signer)) : [];
    return {
      rawTransaction: rawTxn.bcsToBytes(),
      secondarySignerAddresses: signers,
      feePayerAddress: AccountAddress.fromHexInput(feePayerAddress)
    };
  }
  if (secondarySignerAddresses) {
    const signers = secondarySignerAddresses.map(
      (signer) => AccountAddress.fromHexInput(signer)
    );
    return {
      rawTransaction: rawTxn.bcsToBytes(),
      secondarySignerAddresses: signers
    };
  }
  return { rawTransaction: rawTxn.bcsToBytes() };
}
function generateSignedTransactionForSimulation(args) {
  var _a, _b;
  const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;
  const deserializer = new Deserializer(transaction.rawTransaction);
  const deserializedTransaction = RawTransaction.deserialize(deserializer);
  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);
  if (transaction.feePayerAddress) {
    const transactionToSign = new FeePayerRawTransaction(
      deserializedTransaction,
      (_a = transaction.secondarySignerAddresses) != null ? _a : [],
      transaction.feePayerAddress
    );
    let secondaryAccountAuthenticators = [];
    if (secondarySignersPublicKeys) {
      secondaryAccountAuthenticators = secondarySignersPublicKeys.map(
        (publicKey) => getAuthenticatorForSimulation(publicKey)
      );
    }
    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);
    const transactionAuthenticator2 = new TransactionAuthenticatorFeePayer(
      accountAuthenticator,
      (_b = transaction.secondarySignerAddresses) != null ? _b : [],
      secondaryAccountAuthenticators,
      {
        address: transaction.feePayerAddress,
        authenticator: feePayerAuthenticator
      }
    );
    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator2).bcsToBytes();
  }
  if (transaction.secondarySignerAddresses) {
    const transactionToSign = new MultiAgentRawTransaction(
      deserializedTransaction,
      transaction.secondarySignerAddresses
    );
    let secondaryAccountAuthenticators = [];
    secondaryAccountAuthenticators = secondarySignersPublicKeys.map(
      (publicKey) => getAuthenticatorForSimulation(publicKey)
    );
    const transactionAuthenticator2 = new TransactionAuthenticatorMultiAgent(
      accountAuthenticator,
      transaction.secondarySignerAddresses,
      secondaryAccountAuthenticators
    );
    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator2).bcsToBytes();
  }
  let transactionAuthenticator;
  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {
    transactionAuthenticator = new TransactionAuthenticatorEd25519(
      accountAuthenticator.public_key,
      accountAuthenticator.signature
    );
  } else if (accountAuthenticator instanceof AccountAuthenticatorSingleKey) {
    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);
  } else {
    throw new Error("Invalid public key");
  }
  return new SignedTransaction(deserializedTransaction, transactionAuthenticator).bcsToBytes();
}
function getAuthenticatorForSimulation(publicKey) {
  if (publicKey instanceof AnyPublicKey) {
    if (publicKey.publicKey instanceof Ed25519PublicKey) {
      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Ed25519Signature(new Uint8Array(64))));
    }
    if (publicKey.publicKey instanceof Secp256k1PublicKey) {
      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Secp256k1Signature(new Uint8Array(64))));
    }
  }
  return new AccountAuthenticatorEd25519(
    new Ed25519PublicKey(publicKey.toUint8Array()),
    new Ed25519Signature(new Uint8Array(64))
  );
}
function sign(args) {
  const { signer, transaction } = args;
  const transactionToSign = deriveTransactionType(transaction);
  const message = getSigningMessage(transactionToSign);
  const signerSignature = signer.sign(message);
  switch (signer.signingScheme) {
    case 0:
      return new AccountAuthenticatorEd25519(
        new Ed25519PublicKey(signer.publicKey.toUint8Array()),
        new Ed25519Signature(signerSignature.toUint8Array())
      );
    case 2:
      return new AccountAuthenticatorSingleKey(signer.publicKey, new AnySignature(signerSignature));
    default:
      throw new Error(`Cannot sign transaction, signing scheme ${signer.signingScheme} not supported`);
  }
}
function generateSignedTransaction(args) {
  const { transaction, senderAuthenticator, secondarySignerAuthenticators } = args;
  const transactionToSubmit = deriveTransactionType(transaction);
  if (secondarySignerAuthenticators) {
    return generateMultiSignersSignedTransaction(
      transactionToSubmit,
      senderAuthenticator,
      secondarySignerAuthenticators
    );
  }
  if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {
    const transactionAuthenticator = new TransactionAuthenticatorEd25519(
      senderAuthenticator.public_key,
      senderAuthenticator.signature
    );
    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();
  }
  if (senderAuthenticator instanceof AccountAuthenticatorSingleKey || senderAuthenticator instanceof AccountAuthenticatorMultiKey) {
    const transactionAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);
    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();
  }
  throw new Error(
    `Cannot generate a signed transaction, ${senderAuthenticator} is not a supported account authentication scheme`
  );
}
function deriveTransactionType(transaction) {
  var _a;
  const deserializer = new Deserializer(transaction.rawTransaction);
  const deserializedTransaction = RawTransaction.deserialize(deserializer);
  if (transaction.feePayerAddress) {
    return new FeePayerRawTransaction(
      deserializedTransaction,
      (_a = transaction.secondarySignerAddresses) != null ? _a : [],
      transaction.feePayerAddress
    );
  }
  if (transaction.secondarySignerAddresses) {
    return new MultiAgentRawTransaction(deserializedTransaction, transaction.secondarySignerAddresses);
  }
  return deserializedTransaction;
}
function generateMultiSignersSignedTransaction(transaction, senderAuthenticator, secondarySignerAuthenticators) {
  if (transaction instanceof FeePayerRawTransaction) {
    if (!secondarySignerAuthenticators.feePayerAuthenticator) {
      throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
    }
    const { feePayerAuthenticator, additionalSignersAuthenticators } = secondarySignerAuthenticators;
    const txAuthenticatorFeePayer = new TransactionAuthenticatorFeePayer(
      senderAuthenticator,
      transaction.secondary_signer_addresses,
      additionalSignersAuthenticators != null ? additionalSignersAuthenticators : [],
      {
        address: transaction.fee_payer_address,
        authenticator: feePayerAuthenticator
      }
    );
    return new SignedTransaction(transaction.raw_txn, txAuthenticatorFeePayer).bcsToBytes();
  }
  if (transaction instanceof MultiAgentRawTransaction) {
    if (!secondarySignerAuthenticators.additionalSignersAuthenticators) {
      throw new Error(
        "Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction"
      );
    }
    const { additionalSignersAuthenticators } = secondarySignerAuthenticators;
    const multiAgentAuthenticator = new TransactionAuthenticatorMultiAgent(
      senderAuthenticator,
      transaction.secondary_signer_addresses,
      additionalSignersAuthenticators != null ? additionalSignersAuthenticators : []
    );
    return new SignedTransaction(transaction.raw_txn, multiAgentAuthenticator).bcsToBytes();
  }
  throw new Error(
    `Cannot prepare multi signers transaction to submission, ${typeof transaction} transaction is not supported`
  );
}
function getSigningMessage(rawTxn) {
  const hash2 = sha3_256.create();
  if (rawTxn instanceof RawTransaction) {
    hash2.update(RAW_TRANSACTION_SALT);
  } else if (rawTxn instanceof MultiAgentRawTransaction) {
    hash2.update(RAW_TRANSACTION_WITH_DATA_SALT);
  } else if (rawTxn instanceof FeePayerRawTransaction) {
    hash2.update(RAW_TRANSACTION_WITH_DATA_SALT);
  } else {
    throw new Error(`Unknown transaction type to sign on: ${rawTxn}`);
  }
  const prefix = hash2.digest();
  const body = rawTxn.bcsToBytes();
  const mergedArray = new Uint8Array(prefix.length + body.length);
  mergedArray.set(prefix);
  mergedArray.set(body, prefix.length);
  return mergedArray;
}
async function generateTransaction(args) {
  const { aptosConfig, sender, data, options, secondarySignerAddresses, feePayerAddress } = args;
  let generateTransactionPayloadData;
  if ("bytecode" in data) {
    generateTransactionPayloadData = data;
  } else if ("multisigAddress" in data) {
    generateTransactionPayloadData = {
      aptosConfig,
      multisigAddress: data.multisigAddress,
      function: data.function,
      functionArguments: data.functionArguments,
      typeArguments: data.typeArguments
    };
  } else {
    generateTransactionPayloadData = {
      aptosConfig,
      function: data.function,
      functionArguments: data.functionArguments,
      typeArguments: data.typeArguments
    };
  }
  const payload = await generateTransactionPayload(generateTransactionPayloadData);
  return buildTransaction({
    aptosConfig,
    sender,
    payload,
    options,
    secondarySignerAddresses,
    feePayerAddress
  });
}
function signTransaction(args) {
  const accountAuthenticator = sign({ ...args });
  return accountAuthenticator;
}
async function simulateTransaction(args) {
  var _a, _b, _c, _d, _e, _f;
  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;
  const signedTransaction = generateSignedTransactionForSimulation({
    transaction,
    signerPublicKey,
    secondarySignersPublicKeys,
    feePayerPublicKey,
    options
  });
  const { data } = await postAptosFullNode({
    aptosConfig,
    body: signedTransaction,
    path: "transactions/simulate",
    params: {
      estimate_gas_unit_price: (_b = (_a = args.options) == null ? void 0 : _a.estimateGasUnitPrice) != null ? _b : false,
      estimate_max_gas_amount: (_d = (_c = args.options) == null ? void 0 : _c.estimateMaxGasAmount) != null ? _d : false,
      estimate_prioritized_gas_unit_price: (_f = (_e = args.options) == null ? void 0 : _e.estimatePrioritizedGasUnitPrice) != null ? _f : false
    },
    originMethod: "simulateTransaction",
    contentType: "application/x.aptos.signed_transaction+bcs"
    /* BCS_SIGNED_TRANSACTION */
  });
  return data;
}
async function submitTransaction(args) {
  const { aptosConfig } = args;
  const signedTransaction = generateSignedTransaction({ ...args });
  const { data } = await postAptosFullNode({
    aptosConfig,
    body: signedTransaction,
    path: "transactions",
    originMethod: "submitTransaction",
    contentType: "application/x.aptos.signed_transaction+bcs"
    /* BCS_SIGNED_TRANSACTION */
  });
  return data;
}
async function signAndSubmitTransaction(args) {
  const { aptosConfig, signer, transaction } = args;
  const authenticator = signTransaction({ signer, transaction });
  return submitTransaction({
    aptosConfig,
    transaction,
    senderAuthenticator: authenticator
  });
}
async function publicPackageTransaction(args) {
  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;
  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));
  const transaction = await generateTransaction({
    aptosConfig,
    sender: account,
    data: {
      function: "0x1::code::publish_package_txn",
      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)]
    },
    options
  });
  return transaction;
}
async function transferCoinTransaction(args) {
  const { aptosConfig, sender, recipient, amount, coinType, options } = args;
  const coinStructType = coinType != null ? coinType : APTOS_COIN;
  const transaction = await generateTransaction({
    aptosConfig,
    sender: sender.accountAddress.toString(),
    data: {
      function: "0x1::aptos_account::transfer_coins",
      typeArguments: [parseTypeTag(coinStructType)],
      functionArguments: [AccountAddress.fromHexInput(recipient), new U64(amount)]
    },
    options
  });
  return transaction;
}
var Coin = class {
  constructor(config) {
    this.config = config;
  }
  async transferCoinTransaction(args) {
    return transferCoinTransaction({ aptosConfig: this.config, ...args });
  }
};
async function mintTokenTransaction(args) {
  const { aptosConfig, options, creator } = args;
  const transaction = await generateTransaction({
    aptosConfig,
    sender: creator.accountAddress.toString(),
    data: {
      function: "0x4::aptos_token::mint",
      functionArguments: [
        new MoveString(args.collection),
        new MoveString(args.description),
        new MoveString(args.name),
        new MoveString(args.uri),
        MoveVector.MoveString([]),
        MoveVector.MoveString([]),
        new MoveVector([])
      ]
    },
    options
  });
  return transaction;
}
async function getTokenData(args) {
  const { aptosConfig, tokenAddress } = args;
  const whereCondition = {
    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() }
  };
  const graphqlQuery = {
    query: GetTokenData,
    variables: {
      where_condition: whereCondition
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getTokenData"
  });
  return data.current_token_datas_v2[0];
}
async function getCurrentTokenOwnership(args) {
  const { aptosConfig, tokenAddress } = args;
  const whereCondition = {
    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() }
  };
  const graphqlQuery = {
    query: GetCurrentTokenOwnership,
    variables: {
      where_condition: whereCondition
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getCurrentTokenOwnership"
  });
  return data.current_token_ownerships_v2[0];
}
async function getOwnedTokens(args) {
  var _a, _b;
  const { aptosConfig, ownerAddress, options } = args;
  const whereCondition = {
    owner_address: { _eq: Hex.fromHexInput(ownerAddress).toString() }
  };
  const graphqlQuery = {
    query: GetCurrentTokenOwnership,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getOwnedTokens"
  });
  return data.current_token_ownerships_v2;
}
async function getTokenActivity(args) {
  var _a, _b;
  const { aptosConfig, tokenAddress, options } = args;
  const whereCondition = {
    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() }
  };
  const graphqlQuery = {
    query: GetTokenActivity,
    variables: {
      where_condition: whereCondition,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getTokenActivity"
  });
  return data.token_activities_v2;
}
async function createCollectionTransaction(args) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const { aptosConfig, options, creator } = args;
  const transaction = await generateTransaction({
    aptosConfig,
    sender: creator.accountAddress.toString(),
    data: {
      function: "0x4::aptos_token::create_collection",
      functionArguments: [
        new MoveString(args.description),
        new U64((_a = args.maxSupply) != null ? _a : MAX_U64_BIG_INT),
        new MoveString(args.name),
        new MoveString(args.uri),
        new Bool((_b = args.mutableDescription) != null ? _b : true),
        new Bool((_c = args.mutableRoyalty) != null ? _c : true),
        new Bool((_d = args.mutableURI) != null ? _d : true),
        new Bool((_e = args.mutableTokenDescription) != null ? _e : true),
        new Bool((_f = args.mutableTokenName) != null ? _f : true),
        new Bool((_g = args.mutableTokenProperties) != null ? _g : true),
        new Bool((_h = args.mutableTokenURI) != null ? _h : true),
        new Bool((_i = args.tokensBurnableByCreator) != null ? _i : true),
        new Bool((_j = args.tokensFreezableByCreator) != null ? _j : true),
        new U64((_k = args.royaltyNumerator) != null ? _k : 0),
        new U64((_l = args.royaltyDenominator) != null ? _l : 1)
      ]
    },
    options
  });
  return transaction;
}
async function getCollectionData(args) {
  var _a;
  const { aptosConfig, creatorAddress, collectionName, options } = args;
  const address = Hex.fromHexInput(creatorAddress).toString();
  const whereCondition = {
    collection_name: { _eq: collectionName },
    creator_address: { _eq: address }
  };
  if (options == null ? void 0 : options.tokenStandard) {
    whereCondition.token_standard = { _eq: (_a = options == null ? void 0 : options.tokenStandard) != null ? _a : "v2" };
  }
  const graphqlQuery = {
    query: GetCollectionData,
    variables: {
      where_condition: whereCondition
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getCollectionData"
  });
  return data.current_collections_v2[0];
}
async function getCollectionId(args) {
  return (await getCollectionData(args)).collection_id;
}
var DigitalAsset = class {
  constructor(config) {
    this.config = config;
  }
  async createCollectionTransaction(args) {
    return createCollectionTransaction({ aptosConfig: this.config, ...args });
  }
  async getCollectionData(args) {
    return getCollectionData({ aptosConfig: this.config, ...args });
  }
  async getCollectionId(args) {
    return getCollectionId({ aptosConfig: this.config, ...args });
  }
  async mintTokenTransaction(args) {
    return mintTokenTransaction({ aptosConfig: this.config, ...args });
  }
  async getTokenData(args) {
    return getTokenData({ aptosConfig: this.config, ...args });
  }
  async getCurrentTokenOwnership(args) {
    return getCurrentTokenOwnership({ aptosConfig: this.config, ...args });
  }
  async getOwnedTokens(args) {
    return getOwnedTokens({ aptosConfig: this.config, ...args });
  }
  async getTokenActivity(args) {
    return getTokenActivity({ aptosConfig: this.config, ...args });
  }
};
async function getAccountEventsByCreationNumber(args) {
  const { accountAddress, aptosConfig, creationNumber } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    account_address: { _eq: address },
    creation_number: { _eq: creationNumber }
  };
  return getEvents({ aptosConfig, options: { where: whereCondition } });
}
async function getAccountEventsByEventType(args) {
  const { accountAddress, aptosConfig, eventType, options } = args;
  const address = AccountAddress.fromHexInput(accountAddress).toString();
  const whereCondition = {
    account_address: { _eq: address },
    type: { _eq: eventType }
  };
  const customOptions = {
    where: whereCondition,
    pagination: options == null ? void 0 : options.pagination,
    orderBy: options == null ? void 0 : options.orderBy
  };
  return getEvents({ aptosConfig, options: customOptions });
}
async function getEvents(args) {
  var _a, _b;
  const { aptosConfig, options } = args;
  const graphqlQuery = {
    query: GetEvents,
    variables: {
      where_condition: options == null ? void 0 : options.where,
      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,
      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,
      order_by: options == null ? void 0 : options.orderBy
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getEvents"
  });
  return data.events;
}
var Event = class {
  constructor(config) {
    this.config = config;
  }
  async getAccountEventsByCreationNumber(args) {
    return getAccountEventsByCreationNumber({ aptosConfig: this.config, ...args });
  }
  async getAccountEventsByEventType(args) {
    return getAccountEventsByEventType({ aptosConfig: this.config, ...args });
  }
  async getEvents(args) {
    return getEvents({ aptosConfig: this.config, ...args });
  }
};
async function fundAccount(args) {
  const { aptosConfig, accountAddress, amount, options } = args;
  const timeout = (options == null ? void 0 : options.timeoutSecs) || DEFAULT_TXN_TIMEOUT_SEC;
  const { data } = await postAptosFaucet({
    aptosConfig,
    path: "fund",
    body: {
      address: AccountAddress.fromHexInput(accountAddress).toString(),
      amount
    },
    originMethod: "fundAccount"
  });
  const txnHash = data.txn_hashes[0];
  await waitForTransaction({
    aptosConfig,
    transactionHash: txnHash,
    options: {
      timeoutSecs: timeout,
      checkSuccess: options == null ? void 0 : options.checkSuccess,
      indexerVersionCheck: options == null ? void 0 : options.indexerVersionCheck
    }
  });
  return txnHash;
}
var Faucet = class {
  constructor(config) {
    this.config = config;
  }
  async fundAccount(args) {
    return fundAccount({ aptosConfig: this.config, ...args });
  }
};
async function getFungibleAssetMetadata(args) {
  var _a, _b;
  const { aptosConfig, options } = args;
  const graphqlQuery = {
    query: GetFungibleAssetMetadata,
    variables: {
      where_condition: options == null ? void 0 : options.where,
      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,
      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getFungibleAssetMetadata"
  });
  return data.fungible_asset_metadata;
}
async function getFungibleAssetActivities(args) {
  var _a, _b;
  const { aptosConfig, options } = args;
  const graphqlQuery = {
    query: GetFungibleAssetActivities,
    variables: {
      where_condition: options == null ? void 0 : options.where,
      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,
      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getFungibleAssetActivities"
  });
  return data.fungible_asset_activities;
}
async function getCurrentFungibleAssetBalances(args) {
  var _a, _b;
  const { aptosConfig, options } = args;
  const graphqlQuery = {
    query: GetCurrentFungibleAssetBalances,
    variables: {
      where_condition: options == null ? void 0 : options.where,
      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,
      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset
    }
  };
  const data = await queryIndexer({
    aptosConfig,
    query: graphqlQuery,
    originMethod: "getCurrentFungibleAssetBalances"
  });
  return data.current_fungible_asset_balances;
}
var FungibleAsset = class {
  constructor(config) {
    this.config = config;
  }
  async getFungibleAssetMetadata(args) {
    return getFungibleAssetMetadata({ aptosConfig: this.config, ...args });
  }
  async getFungibleAssetMetadataByAssetType(assetType) {
    const data = await getFungibleAssetMetadata({
      aptosConfig: this.config,
      options: {
        where: {
          asset_type: { _eq: assetType }
        }
      }
    });
    return data[0];
  }
  async getFungibleAssetActivities(args) {
    return getFungibleAssetActivities({ aptosConfig: this.config, ...args });
  }
  async getCurrentFungibleAssetBalances(args) {
    return getCurrentFungibleAssetBalances({ aptosConfig: this.config, ...args });
  }
};
var General = class {
  constructor(config) {
    this.config = config;
  }
  async getLedgerInfo() {
    return getLedgerInfo({ aptosConfig: this.config });
  }
  async getChainId() {
    const result = await this.getLedgerInfo();
    return result.chain_id;
  }
  async getBlockByVersion(args) {
    return getBlockByVersion({
      aptosConfig: this.config,
      ...args
    });
  }
  async getBlockByHeight(args) {
    return getBlockByHeight({ aptosConfig: this.config, ...args });
  }
  async getTableItem(args) {
    return getTableItem({ aptosConfig: this.config, ...args });
  }
  async view(args) {
    return view({ aptosConfig: this.config, ...args });
  }
  async getChainTopUserTransactions(args) {
    return getChainTopUserTransactions({
      aptosConfig: this.config,
      ...args
    });
  }
  async queryIndexer(args) {
    return queryIndexer({
      aptosConfig: this.config,
      ...args
    });
  }
  async getIndexerLastSuccessVersion() {
    return getIndexerLastSuccessVersion({ aptosConfig: this.config });
  }
};
async function getNumberOfDelegators(args) {
  const { aptosConfig, poolAddress } = args;
  const address = Hex.fromHexInput(poolAddress).toString();
  const query = {
    query: GetNumberOfDelegators,
    variables: { where_condition: { pool_address: { _eq: address } } }
  };
  const data = await queryIndexer({ aptosConfig, query });
  if (data.num_active_delegator_per_pool.length === 0) {
    throw Error("Delegator pool not found");
  }
  return data.num_active_delegator_per_pool[0].num_active_delegator;
}
async function getNumberOfDelegatorsForAllPools(args) {
  const { aptosConfig, options } = args;
  const query = {
    query: GetNumberOfDelegators,
    variables: { where_condition: {}, order_by: options == null ? void 0 : options.orderBy }
  };
  const data = await queryIndexer({
    aptosConfig,
    query
  });
  return data.num_active_delegator_per_pool;
}
async function getDelegatedStakingActivities(args) {
  const { aptosConfig, delegatorAddress, poolAddress } = args;
  const query = {
    query: GetDelegatedStakingActivities,
    variables: {
      delegatorAddress: Hex.fromHexInput(delegatorAddress).toString(),
      poolAddress: Hex.fromHexInput(poolAddress).toString()
    }
  };
  const data = await queryIndexer({ aptosConfig, query });
  return data.delegated_staking_activities;
}
var Staking = class {
  constructor(config) {
    this.config = config;
  }
  async getNumberOfDelegators(args) {
    return getNumberOfDelegators({ aptosConfig: this.config, ...args });
  }
  async getNumberOfDelegatorsForAllPools(args) {
    return getNumberOfDelegatorsForAllPools({ aptosConfig: this.config, ...args });
  }
  async getDelegatedStakingActivities(args) {
    return getDelegatedStakingActivities({ aptosConfig: this.config, ...args });
  }
};
var Transaction = class {
  constructor(config) {
    this.config = config;
  }
  async getTransactions(args) {
    return getTransactions2({
      aptosConfig: this.config,
      ...args
    });
  }
  async getTransactionByVersion(args) {
    return getTransactionByVersion({
      aptosConfig: this.config,
      ...args
    });
  }
  async getTransactionByHash(args) {
    return getTransactionByHash({
      aptosConfig: this.config,
      ...args
    });
  }
  async isPendingTransaction(args) {
    return isTransactionPending({
      aptosConfig: this.config,
      ...args
    });
  }
  async waitForTransaction(args) {
    return waitForTransaction({
      aptosConfig: this.config,
      ...args
    });
  }
  async getGasPriceEstimation() {
    return getGasPriceEstimation({
      aptosConfig: this.config
    });
  }
};
var TransactionSubmission = class {
  constructor(config) {
    this.config = config;
  }
  async generateTransaction(args) {
    return generateTransaction({ aptosConfig: this.config, ...args });
  }
  signTransaction(args) {
    return signTransaction({ ...args });
  }
  async simulateTransaction(args) {
    return simulateTransaction({ aptosConfig: this.config, ...args });
  }
  async submitTransaction(args) {
    return submitTransaction({ aptosConfig: this.config, ...args });
  }
  async signAndSubmitTransaction(args) {
    const { signer, transaction } = args;
    return signAndSubmitTransaction({
      aptosConfig: this.config,
      signer,
      transaction
    });
  }
  async publishPackageTransaction(args) {
    return publicPackageTransaction({ aptosConfig: this.config, ...args });
  }
};
var Aptos = class {
  constructor(settings) {
    this.config = new AptosConfig(settings);
    this.account = new Account2(this.config);
    this.coin = new Coin(this.config);
    this.digitalAsset = new DigitalAsset(this.config);
    this.event = new Event(this.config);
    this.faucet = new Faucet(this.config);
    this.fungibleAsset = new FungibleAsset(this.config);
    this.general = new General(this.config);
    this.staking = new Staking(this.config);
    this.transaction = new Transaction(this.config);
    this.transactionSubmission = new TransactionSubmission(this.config);
  }
};
function applyMixin(targetClass, baseClass, baseClassProp) {
  Object.getOwnPropertyNames(baseClass.prototype).forEach((propertyName) => {
    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);
    if (!propertyDescriptor)
      return;
    propertyDescriptor.value = function(...args) {
      return this[baseClassProp][propertyName](...args);
    };
    Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);
  });
}
applyMixin(Aptos, Account2, "account");
applyMixin(Aptos, Coin, "coin");
applyMixin(Aptos, DigitalAsset, "digitalAsset");
applyMixin(Aptos, Event, "event");
applyMixin(Aptos, Faucet, "faucet");
applyMixin(Aptos, FungibleAsset, "fungibleAsset");
applyMixin(Aptos, General, "general");
applyMixin(Aptos, Staking, "staking");
applyMixin(Aptos, Transaction, "transaction");
applyMixin(Aptos, TransactionSubmission, "transactionSubmission");

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var WalletReadyState = ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName = ((NetworkName2) => {
  NetworkName2["Mainnet"] = "mainnet";
  NetworkName2["Testnet"] = "testnet";
  NetworkName2["Devnet"] = "devnet";
  return NetworkName2;
})(NetworkName || {});
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletConnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
var WalletDisconnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
};
var WalletAccountError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
};
var WalletGetNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
};
var WalletAccountChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
};
var WalletNetworkChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};
var WalletSignMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
var WalletSignMessageAndVerifyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageAndVerifyError";
  }
};
var WalletSignAndSubmitMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
};
var WalletSignTransactionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
var WalletNotSupportedMethod = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSupportedMethod";
  }
};
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = setInterval(detectAndDispose, 1e3);
  disposers.push(() => clearInterval(interval));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", detectAndDispose, {
      once: true
    });
    disposers.push(
      () => document.removeEventListener("DOMContentLoaded", detectAndDispose)
    );
  }
  if (document.readyState !== "complete") {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(
    navigator.userAgent
  );
}
function isInAppBrowser() {
  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
    navigator.userAgent
  );
  const isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(
    navigator.userAgent
  );
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator)
    return false;
  return isMobile() && !isInAppBrowser();
}
var ChainIdToAnsContractAddressMap = {
  "1": "mainnet",
  "2": "testnet"
};
var getNameByAddress = async (chainId, address) => {
  try {
    if (!ChainIdToAnsContractAddressMap[chainId])
      return null;
    const response = await fetch(
      `https://www.aptosnames.com/api/${ChainIdToAnsContractAddressMap[chainId]}/v1/name/${address}`
    );
    const data = await response.json();
    return data.name;
  } catch (e) {
    console.log("error", e);
    return null;
  }
};
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name.toLowerCase()) {
    case "mainnet":
      return Network.MAINNET;
    case "testnet":
      return Network.TESTNET;
    case "devnet":
      return Network.DEVNET;
    default:
      throw new Error("Invalid network name");
  }
}
function convertToBCSPayload(payload) {
  const deserializer = new bcs_exports.Deserializer(payload.bcsToBytes());
  return aptos_types_exports.TransactionPayload.deserialize(deserializer);
}
var WalletCore = class extends import_eventemitter3.default {
  constructor(plugins) {
    super();
    this._wallets = [];
    this._wallet = null;
    this._account = null;
    this._network = null;
    this._connecting = false;
    this._connected = false;
    this._wallets = plugins;
    this.scopePollingDetectionStrategy();
  }
  scopePollingDetectionStrategy() {
    var _a;
    (_a = this._wallets) == null ? void 0 : _a.forEach((wallet) => {
      if (!wallet.readyState) {
        wallet.readyState = typeof window === "undefined" || typeof document === "undefined" ? "Unsupported" : "NotDetected";
      }
      if (typeof window !== "undefined") {
        scopePollingDetectionStrategy(() => {
          const providerName = wallet.providerName || wallet.name.toLowerCase();
          if (Object.keys(window).includes(providerName)) {
            wallet.readyState = "Installed";
            wallet.provider = window[providerName];
            this.emit("readyStateChange", wallet);
            return true;
          }
          return false;
        });
      }
    });
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new WalletNotConnectedError().name;
    if (!(this._wallet.readyState === "Loadable" || this._wallet.readyState === "Installed"))
      throw new WalletNotReadyError().name;
    return true;
  }
  clearData() {
    this._connected = false;
    this.setWallet(null);
    this.setAccount(null);
    this.setNetwork(null);
    removeLocalStorage();
  }
  async setAnsName() {
    var _a;
    if (((_a = this._network) == null ? void 0 : _a.chainId) && this._account) {
      const name = await getNameByAddress(
        this._network.chainId,
        this._account.address
      );
      this._account.ansName = name;
    }
  }
  setWallet(wallet) {
    this._wallet = wallet;
  }
  setAccount(account) {
    this._account = account;
  }
  setNetwork(network) {
    this._network = network;
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._wallets;
  }
  get wallet() {
    try {
      if (!this._wallet)
        return null;
      return {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      };
    } catch (error) {
      throw new WalletNotSelectedError(error).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (error) {
      throw new WalletAccountError(error).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (error) {
      throw new WalletGetNetworkError(error).message;
    }
  }
  async connect(walletName) {
    var _a;
    const selectedWallet = (_a = this._wallets) == null ? void 0 : _a.find(
      (wallet) => wallet.name === walletName
    );
    if (!selectedWallet)
      return;
    if (this._connected) {
      if (selectedWallet.name === walletName)
        throw new WalletConnectionError(
          `${walletName} wallet is already connected`
        ).message;
    }
    if (isRedirectable()) {
      if (selectedWallet.deeplinkProvider) {
        const url = encodeURIComponent(window.location.href);
        const location = selectedWallet.deeplinkProvider({ url });
        window.location.href = location;
      }
    }
    if (selectedWallet.readyState !== "Installed" && selectedWallet.readyState !== "Loadable") {
      return;
    }
    await this.connectWallet(selectedWallet);
  }
  async connectWallet(selectedWallet) {
    try {
      this._connecting = true;
      this.setWallet(selectedWallet);
      const account = await selectedWallet.connect();
      this.setAccount({ ...account });
      const network = await selectedWallet.network();
      this.setNetwork({ ...network });
      await this.setAnsName();
      setLocalStorage(selectedWallet.name);
      this._connected = true;
      this.emit("connect", account);
    } catch (error) {
      this.clearData();
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletConnectionError(errMsg).message;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.disconnect());
      this.clearData();
      this.emit("disconnect");
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletDisconnectionError(errMsg).message;
    }
  }
  async signAndSubmitTransaction(transaction, options) {
    var _a;
    try {
      this.doesWalletExist();
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signAndSubmitTransaction(
        transaction,
        options
      ));
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signAndSubmitBCSTransaction(transaction, options) {
    var _a;
    if (this._wallet && !("signAndSubmitBCSTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Submit a BCS Transaction is not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const response = await this._wallet.signAndSubmitBCSTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, options) {
    var _a;
    if (this._wallet && !("signTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Sign Transaction is not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const response = await this._wallet.signTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessage(message) {
    var _a;
    try {
      this.doesWalletExist();
      if (!this._wallet)
        return null;
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signMessage(message));
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async submitTransaction(transactionInput, options) {
    const payloadData = transactionInput.data;
    const aptosConfig = new AptosConfig({ network: convertNetwork(this._network) });
    const newPayload = await generateTransactionPayload({ ...payloadData, aptosConfig });
    const oldTransactionPayload = convertToBCSPayload(newPayload);
    const response = await this.signAndSubmitBCSTransaction(oldTransactionPayload, options);
    const { hash: hash2, ...output2 } = response;
    return { hash: hash2, output: output2 };
  }
  async signMultiAgentTransaction(transaction) {
    var _a;
    if (this._wallet && !("signMultiAgentTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Multi-agent & sponsored transactions are not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const response = await this._wallet.signMultiAgentTransaction(
        transaction
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async onAccountChange() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.onAccountChange(async (data) => {
        this.setAccount({ ...data });
        await this.setAnsName();
        this.emit("accountChange", this._account);
      }));
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletAccountChangeError(errMsg).message;
    }
  }
  async onNetworkChange() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.onNetworkChange(async (data) => {
        this.setNetwork({ ...data });
        await this.setAnsName();
        this.emit("networkChange", this._network);
      }));
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletNetworkChangeError(errMsg).message;
    }
  }
  async signMessageAndVerify(message) {
    var _a;
    try {
      this.doesWalletExist();
      if (!this._account)
        throw new Error("No account found!");
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signMessage(message));
      if (!response)
        throw new WalletSignMessageAndVerifyError("Failed to sign a message").message;
      let verified = false;
      if (Array.isArray(response.signature)) {
        const { fullMessage, signature, bitmap } = response;
        if (bitmap) {
          const minKeysRequired = this._account.minKeysRequired;
          if (signature.length < minKeysRequired) {
            verified = false;
          } else {
            const bits = Array.from(bitmap).flatMap(
              (n) => Array.from({ length: 8 }).map((_, i) => n >> i & 1)
            );
            const index = bits.map((_, i) => i).filter((i) => bits[i]);
            const publicKeys = this._account.publicKey;
            const matchedPublicKeys = publicKeys.filter(
              (_, i) => index.includes(i)
            );
            verified = true;
            for (let i = 0; i < signature.length; i++) {
              const isSigVerified = import_tweetnacl2.default.sign.detached.verify(
                import_buffer.Buffer.from(fullMessage),
                import_buffer.Buffer.from(signature[i], "hex"),
                import_buffer.Buffer.from(matchedPublicKeys[i], "hex")
              );
              if (!isSigVerified) {
                verified = false;
                break;
              }
            }
          }
        } else {
          throw new WalletSignMessageAndVerifyError("Failed to get a bitmap").message;
        }
      } else {
        const currentAccountPublicKey = new HexString(
          this._account.publicKey
        );
        const signature = new HexString(response.signature);
        verified = import_tweetnacl2.default.sign.detached.verify(
          import_buffer.Buffer.from(response.fullMessage),
          import_buffer.Buffer.from(signature.noPrefix(), "hex"),
          import_buffer.Buffer.from(currentAccountPublicKey.noPrefix(), "hex")
        );
      }
      return verified;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var DEFAULT_COUNTEXT = {
  connected: false
};
var WalletContext = (0, import_react.createContext)(
  DEFAULT_COUNTEXT
);
function useWallet() {
  const context = (0, import_react.useContext)(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletContextState");
  }
  return context;
}
var initialState = {
  connected: false,
  account: null,
  network: null,
  wallet: null
};
var AptosWalletAdapterProvider = ({
  children,
  plugins,
  autoConnect = false,
  onError
}) => {
  const [{ connected, account, network, wallet }, setState] = (0, import_react2.useState)(initialState);
  const [isLoading, setIsLoading] = (0, import_react2.useState)(true);
  const walletCore = (0, import_react2.useMemo)(() => new WalletCore(plugins), []);
  const [wallets, setWallets] = (0, import_react2.useState)(
    walletCore.wallets
  );
  const connect = async (walletName) => {
    try {
      setIsLoading(true);
      await walletCore.connect(walletName);
    } catch (error) {
      console.log("connect error", error);
      if (onError)
        onError(error);
      else
        throw error;
    } finally {
      setIsLoading(false);
    }
  };
  const disconnect = async () => {
    try {
      await walletCore.disconnect();
    } catch (e) {
      console.log("disconnect error", e);
      if (onError)
        onError(e);
    }
  };
  const signAndSubmitTransaction2 = async (transaction, options) => {
    try {
      return await walletCore.signAndSubmitTransaction(transaction, options);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
    }
  };
  const signAndSubmitBCSTransaction = async (transaction, options) => {
    try {
      return await walletCore.signAndSubmitBCSTransaction(transaction, options);
    } catch (error) {
      throw error;
    }
  };
  const signTransaction2 = async (transaction, options) => {
    try {
      return await walletCore.signTransaction(transaction, options);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
    }
  };
  const signMessage = async (message) => {
    try {
      return await walletCore.signMessage(message);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
      return null;
    }
  };
  const signMessageAndVerify = async (message) => {
    try {
      return await walletCore.signMessageAndVerify(message);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
      return false;
    }
  };
  const signMultiAgentTransaction = async (transaction) => {
    try {
      return await walletCore.signMultiAgentTransaction(transaction);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
      return false;
    }
  };
  const submitTransaction2 = async (transaction) => {
    try {
      return await walletCore.submitTransaction(transaction);
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
      return false;
    }
  };
  (0, import_react2.useEffect)(() => {
    if (autoConnect) {
      if (localStorage.getItem("AptosWalletName")) {
        connect(localStorage.getItem("AptosWalletName"));
      } else {
        setIsLoading(false);
      }
    }
  }, wallets);
  (0, import_react2.useEffect)(() => {
    if (connected) {
      walletCore.onAccountChange();
      walletCore.onNetworkChange();
    }
  }, [...wallets, connected]);
  const handleConnect = () => {
    setState((state) => {
      return {
        ...state,
        connected: true,
        account: walletCore.account,
        network: walletCore.network,
        wallet: walletCore.wallet
      };
    });
  };
  const handleDisconnect = () => {
    if (!connected)
      return;
    setState((state) => {
      return {
        ...state,
        connected: false,
        account: walletCore.account,
        network: walletCore.network,
        wallet: null
      };
    });
  };
  const handleAccountChange = (0, import_react2.useCallback)(() => {
    if (!connected)
      return;
    if (!walletCore.wallet)
      return;
    setState((state) => {
      return {
        ...state,
        account: walletCore.account
      };
    });
  }, [connected]);
  const handleNetworkChange = (0, import_react2.useCallback)(() => {
    if (!connected)
      return;
    if (!walletCore.wallet)
      return;
    setState((state) => {
      return {
        ...state,
        network: walletCore.network
      };
    });
  }, [connected]);
  const handleReadyStateChange = (wallet2) => {
    setWallets((wallets2) => [...wallets2]);
  };
  (0, import_react2.useEffect)(() => {
    walletCore.on("connect", handleConnect);
    walletCore.on("disconnect", handleDisconnect);
    walletCore.on("accountChange", handleAccountChange);
    walletCore.on("networkChange", handleNetworkChange);
    walletCore.on("readyStateChange", handleReadyStateChange);
    return () => {
      walletCore.off("connect", handleConnect);
      walletCore.off("disconnect", handleDisconnect);
      walletCore.off("accountChange", handleAccountChange);
      walletCore.off("networkChange", handleNetworkChange);
      walletCore.off("readyStateChange", handleReadyStateChange);
    };
  }, [...wallets, connected]);
  return (0, import_jsx_runtime.jsx)(WalletContext.Provider, {
    value: {
      connect,
      account,
      network,
      connected,
      disconnect,
      wallet,
      wallets,
      signAndSubmitTransaction: signAndSubmitTransaction2,
      signAndSubmitBCSTransaction,
      signTransaction: signTransaction2,
      signMessage,
      signMessageAndVerify,
      signMultiAgentTransaction,
      submitTransaction: submitTransaction2,
      isLoading
    },
    children
  });
};

export {
  WalletReadyState,
  NetworkName,
  isMobile,
  isInAppBrowser,
  isRedirectable,
  useWallet,
  AptosWalletAdapterProvider
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-HQQMQZ6B.js.map
